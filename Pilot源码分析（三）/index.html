<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="本篇主要探讨上一篇源码分析中留下的问题，如 EnvoyXdsServer 是如何工作的，以及 xDS 的下发流程。对推送事件的防抖、SidecarScope 的运用做一些细致的分析。 EnvoyXdsServerEnvoyXdsServer 主要负责 Pilot 中 xDS 协议的生成和下发，接收并处理 configController 和 serviceController 推送的 PushRe">
<meta property="og:type" content="article">
<meta property="og:title" content="Istio Pilot 源码分析（三）">
<meta property="og:url" content="https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/index.html">
<meta property="og:site_name" content="海东的博客">
<meta property="og:description" content="本篇主要探讨上一篇源码分析中留下的问题，如 EnvoyXdsServer 是如何工作的，以及 xDS 的下发流程。对推送事件的防抖、SidecarScope 的运用做一些细致的分析。 EnvoyXdsServerEnvoyXdsServer 主要负责 Pilot 中 xDS 协议的生成和下发，接收并处理 configController 和 serviceController 推送的 PushRe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://haidong.dev/images/pilot-discovery-sequence-init.png">
<meta property="og:image" content="https://haidong.dev/images/envoyxdsserver-reveive-conn.png">
<meta property="og:image" content="https://haidong.dev/images/envoyxdsserver-receive-change.png">
<meta property="og:image" content="https://haidong.dev/images/envoyxdsserver-handleudpate.png">
<meta property="og:image" content="https://haidong.dev/images/push-channel-source.png">
<meta property="og:image" content="https://haidong.dev/images/envoyxdsserver-sendpushes.png">
<meta property="og:image" content="https://haidong.dev/images/envoyxdsserver-client-requests.png">
<meta property="article:published_time" content="2020-09-25T07:27:16.000Z">
<meta property="article:modified_time" content="2020-09-30T03:19:10.817Z">
<meta property="article:author" content="zhd173">
<meta property="article:tag" content="cloudnative">
<meta property="article:tag" content="go">
<meta property="article:tag" content="servicemesh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://haidong.dev/images/pilot-discovery-sequence-init.png">
    
    
        
          
              <link rel="shortcut icon" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=16">
          
        
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=192" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=180">
          
        
    
    <!-- title -->
    <title>Istio Pilot 源码分析（三）</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/%E8%AE%B0%E4%B8%80%E6%AC%A1Pilot%E6%8E%A8%E9%80%81%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%E8%BF%87%E7%A8%8B/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&text=Istio Pilot 源码分析（三）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&is_video=false&description=Istio Pilot 源码分析（三）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Istio Pilot 源码分析（三）&body=Check out this article: https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&name=Istio Pilot 源码分析（三）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&t=Istio Pilot 源码分析（三）"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EnvoyXdsServer"><span class="toc-number">1.</span> <span class="toc-text">EnvoyXdsServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialization"><span class="toc-number">1.1.</span> <span class="toc-text">Initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Receive-Connection"><span class="toc-number">1.2.</span> <span class="toc-text">Receive Connection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Receive-Change"><span class="toc-number">1.3.</span> <span class="toc-text">Receive Change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handle-Updates"><span class="toc-number">1.4.</span> <span class="toc-text">Handle Updates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Send-Pushes"><span class="toc-number">1.5.</span> <span class="toc-text">Send Pushes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-Request"><span class="toc-number">1.6.</span> <span class="toc-text">Client Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Istio Pilot 源码分析（三）
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">海东的博客</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-09-25T07:27:16.000Z" itemprop="datePublished">2020-09-25</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/cloudnative/" rel="tag">cloudnative</a>, <a class="tag-link-link" href="/tags/go/" rel="tag">go</a>, <a class="tag-link-link" href="/tags/servicemesh/" rel="tag">servicemesh</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p>本篇主要探讨上一篇源码分析中留下的问题，如 <code>EnvoyXdsServer</code> 是如何工作的，以及 xDS 的下发流程。对推送事件的防抖、<code>SidecarScope</code> 的运用做一些细致的分析。</p>
<h2 id="EnvoyXdsServer"><a href="#EnvoyXdsServer" class="headerlink" title="EnvoyXdsServer"></a>EnvoyXdsServer</h2><p><code>EnvoyXdsServer</code> 主要负责 Pilot 中 xDS 协议的生成和下发，接收并处理 <code>configController</code> 和 <code>serviceController</code> 推送的 PushRequest ，与集群中所有的数据面代理进行 gRPC 通信，并处理它们的请求。在 Pilot Server 中的定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Server contains the runtime configuration for the Pilot discovery service.</span></span><br><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  EnvoyXdsServer *xds.DiscoveryServer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>EnvoyXdsServer</code> 只是 Pilot Server 中的别名，真正的 <code>xds.DiscoveryServer</code> 结构在 <code>istio/pilot/pkg/xds/discovery.go:71</code> 中，这里只保留关键的字段进行说明：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DiscoveryServer is Pilot&#x27;s gRPC implementation for Envoy&#x27;s v2 xds APIs</span></span><br><span class="line"><span class="keyword">type</span> DiscoveryServer <span class="keyword">struct</span> &#123;</span><br><span class="line">  Env *model.Environment <span class="comment">// 与 Pilot Server 中的 Environment 一样</span></span><br><span class="line">  ConfigGenerator core.ConfigGenerator <span class="comment">// xDS 数据的生成器接口</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Endpoint 的缓存，以服务名和 namespace 作为索引，主要用于 EDS 更新</span></span><br><span class="line">  EndpointShardsByService <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]*EndpointShards</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 统一接收其他组件发来的 PushRequest 的 channel</span></span><br><span class="line">  pushChannel <span class="keyword">chan</span> *model.PushRequest</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pushQueue 主要是在真正 xDS 推送前做防抖缓存</span></span><br><span class="line">  pushQueue *PushQueue</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 保存了所有生效的 gRPC 连接</span></span><br><span class="line">  adsClients      <span class="keyword">map</span>[<span class="keyword">string</span>]*Connection</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h3><p>回忆一下 pilot-discovery 的启动流程：</p>
<p><img src="/images/pilot-discovery-sequence-init.png" alt="pilot-discovery init"></p>
<p>在初始化 grpcServer 的时候，调用了 <code>DiscoveryServer.Register()</code> 方法，向 grpcServer 注册了以下几个服务（以 v2 版本为例）：</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">AggregatedDiscoveryService</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 全量 ADS Stream 接口</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> StreamAggregatedResources(stream api.v2.DiscoveryRequest)</span></span><br><span class="line"><span class="function">      <span class="keyword">returns</span> (stream api.v2.DiscoveryResponse) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 增量 ADS Stream 接口</span></span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> DeltaAggregatedResources(stream api.v2.DeltaDiscoveryRequest)</span></span><br><span class="line"><span class="function">      <span class="keyword">returns</span> (stream api.v2.DeltaDiscoveryResponse) </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的 proto 文件可以在 <a target="_blank" rel="noopener" href="https://github.com/envoyproxy/envoy/blob/master/api/envoy/service/discovery/v2/ads.proto">ads.proto</a> 找到。熟悉 gRPC 的读者可以看到这个服务定义了两个 RPC 接口：</p>
<ol>
<li><code>StreamAggregatedResources</code> 接收 <code>DiscoveryRequest</code> ，返回 <code>DiscoveryResponse</code> 流，包含全量的 xDS 数据</li>
<li><code>DeltaAggregatedResources</code> 接收 <code>DeltaDiscoveryRequest</code> ，返回 <code>DeltaDiscoveryResponse</code> 流，包含增量的 xDS 数据</li>
</ol>
<p>xDS 相关的介绍可以参考 Envoy 的文档：<a target="_blank" rel="noopener" href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol">xDS REST and gRPC protocol</a> ，写的很详细。</p>
<p><code>EnvoyXdsServer</code> 在启动方法 Start() 中开启了两个比较重要的协程 <code>handleUpdates</code> 和 <code>sendPushes</code> 。 <code>handleUpdates</code> 主要用来处理 <code>pushChannel</code> 中收到的推送请求以及防抖。 <code>sendPushes</code> 则负责具体的推送。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  adsLog.Infof(<span class="string">&quot;Starting ADS server&quot;</span>)</span><br><span class="line">  <span class="keyword">go</span> s.handleUpdates(stopCh)</span><br><span class="line">  <span class="keyword">go</span> s.periodicRefreshMetrics(stopCh)</span><br><span class="line">  <span class="keyword">go</span> s.sendPushes(stopCh)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-Connection"><a href="#Receive-Connection" class="headerlink" title="Receive Connection"></a>Receive Connection</h3><p>当服务实例的代理（ Sidecar 模式） 启动的时候，会和 grpcServer 建立连接并调用 <code>StreamAggregatedResources</code> 方法：</p>
<p><img src="/images/envoyxdsserver-reveive-conn.png" alt="EnvoyXdsServer Receive Connection"></p>
<p><code>StreamAggregatedResources</code> 会和当前的 Proxy 创建一个连接，并创建一个接受请求的 <code>reqChannel</code> 。同时开启一个新的协程 <code>receiveThread</code> 处理客户端主动发起的请求：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">StreamAggregatedResources</span><span class="params">(stream discovery.AggregatedDiscoveryService_StreamAggregatedResourcesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  con := newConnection(peerAddr, stream)</span><br><span class="line">  <span class="keyword">var</span> receiveError error</span><br><span class="line">  reqChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> *discovery.DiscoveryRequest, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> s.receiveThread(con, reqChannel, &amp;receiveError)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Receive-Change"><a href="#Receive-Change" class="headerlink" title="Receive Change"></a>Receive Change</h3><p>一切准备就绪之后， <code>EnvoyXdsServer</code> 开始接收来自 <code>configController</code> 和 <code>serviceController</code> 的配置变化事件，包括服务数据的变化和配置数据的变化，都会创建 PushRequest 发送至 <code>EnvoyXdsServer</code> 的 <code>pushChannel</code> :</p>
<p><img src="/images/envoyxdsserver-receive-change.png" alt="EnvoyXdsServer Receive Change"></p>
<p>PushRequest 包含是否全量推送的标识以及主要更改的资源类型。全部统一推送到 <code>pushChannel</code> 之后，就由 <code>EnvoyXdsServer</code> 启动时创建的协程 <code>handleUpdates</code> 来处理了。</p>
<h3 id="Handle-Updates"><a href="#Handle-Updates" class="headerlink" title="Handle Updates"></a>Handle Updates</h3><p><code>handleUpdates</code> 最重要的功能就是防抖，避免因过快的推送带来的问题和压力。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Debouncing and push request happens in a separate thread, it uses locks</span></span><br><span class="line"><span class="comment">// and we want to avoid complications, ConfigUpdate may already hold other locks.</span></span><br><span class="line"><span class="comment">// handleUpdates processes events from pushChannel</span></span><br><span class="line"><span class="comment">// It ensures that at minimum minQuiet time has elapsed since the last event before processing it.</span></span><br><span class="line"><span class="comment">// It also ensures that at most maxDelay is elapsed between receiving an event and processing it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">handleUpdates</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  debounce(s.pushChannel, stopCh, s.Push)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/images/envoyxdsserver-handleudpate.png" alt="EnvoyXdsServer Handle Update"></p>
<p>什么是防抖（ <code>Debounce</code> ）呢？举一个简单的例子，我们每天上班都要坐电梯，当你第一个进电梯后，想上 5 楼，按下了 5 楼并关闭了电梯门，门还没关上的时候，突然碰到一个同事，电梯门又打开，同事进来后你们一起去了 5 楼。这样两个人两次去 5 楼的事件，电梯跑了一趟就解决了。试想如果电梯的门都是秒关不等人，每次只装一个人，第二个人必须等电梯把上一个人送到之后才能重新乘坐，就算写字楼有很多电梯也会在早高峰的时候产生拥挤。</p>
<p>假设电梯容量无限大，你有无数个同事，今天好巧不巧每次电梯快关上的时候都有个同事要进来，门永远关不上，电梯也一直不走，那好了大家今天谁也别想上班，也是个很大的问题。那我们做一个规定，每趟电梯在 1 楼的时候最多等待 3 分钟，到时间了电梯就走，这样电梯的利用率就提升了，大家也不用等太久就可以上班打卡。</p>
<p>如果优化的更好一点，把所有电梯分成奇偶两组，奇组只在奇数层停，偶组只在偶数层停。这样就可以最大化的提升资源利用率。但还有一种情况，如果我们进电梯后，后面没有人进电梯了，白白等待了 3 分钟电梯才走，浪费了时间，这也不行。</p>
<p>那我们就再给电梯系统加一个时间，让电梯在有人进电梯后等待 10 秒，如果过了 10 秒还没有下一个人进来，电梯就不等了。 如有有人进来就重新计时 10 秒钟。</p>
<p>从上面这个例子可以引申出几个概念，一个是最小静默时间，一个是最大延迟时间。最小静默时间就是上面的 10 秒钟，从上一个进电梯的人开始计时，10 秒内有新的人进来就接着等，否则就不等，每进一个人就重新计算这个时间。最大延迟时间就是上面电梯等待的 3 分钟，到了这个时间就算还有很多人没有进电梯，电梯也必须走。另外一个防抖中的重要概念就是分组合并，比如把都去偶数层的人统一在一趟电梯上。</p>
<p><code>EnvoyXdsServer</code> 的防抖函数也一样，把要推送的请求根据资源类型、事件类型分组或者合并，并在 <code>minQuite</code> 时间内等待下一个请求，超过 <code>maxDelay</code> 时间就进行下一步处理。</p>
<p>在 Pilot 中最小静默时间可以通过 <code>PILOT_DEBOUNCE_AFTER</code> 这个环境变量设置，默认为 100 毫秒，最大延迟时间可以通过 <code>PILOT_DEBOUNCE_MAX</code> 设置，默认为 10 秒。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// isti/pilot/pkg/features/pilot.go</span></span><br><span class="line"></span><br><span class="line">DebounceAfter = env.RegisterDurationVar(</span><br><span class="line">  <span class="string">&quot;PILOT_DEBOUNCE_AFTER&quot;</span>,</span><br><span class="line">  <span class="number">100</span>*time.Millisecond,</span><br><span class="line">  <span class="string">&quot;The delay added to config/registry events for debouncing. This will delay the push by &quot;</span>+</span><br><span class="line">    <span class="string">&quot;at least this internal. If no change is detected within this period, the push will happen, &quot;</span>+</span><br><span class="line">    <span class="string">&quot; otherwise we&#x27;ll keep delaying until things settle, up to a max of PILOT_DEBOUNCE_MAX.&quot;</span>,</span><br><span class="line">).Get()</span><br><span class="line"></span><br><span class="line">DebounceMax = env.RegisterDurationVar(</span><br><span class="line">  <span class="string">&quot;PILOT_DEBOUNCE_MAX&quot;</span>,</span><br><span class="line">  <span class="number">10</span>*time.Second,</span><br><span class="line">  <span class="string">&quot;The maximum amount of time to wait for events while debouncing. If events keep showing up with no breaks &quot;</span>+</span><br><span class="line">    <span class="string">&quot;for this time, we&#x27;ll trigger a push.&quot;</span>,</span><br><span class="line">).Get()</span><br></pre></td></tr></table></figure>

<p>来看一下 <code>debounce</code> 方法中定义的 <code>pushWorker</code> ，主要的判断逻辑就定义在这里：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pushWorker := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">  eventDelay := time.Since(startDebounce)</span><br><span class="line">  quietTime := time.Since(lastConfigUpdateTime)</span><br><span class="line">  <span class="comment">// it has been too long or quiet enough</span></span><br><span class="line">  <span class="keyword">if</span> eventDelay &gt;= debounceMax || quietTime &gt;= debounceAfter &#123;</span><br><span class="line">    <span class="keyword">if</span> req != <span class="literal">nil</span> &#123;</span><br><span class="line">      pushCounter++</span><br><span class="line">      adsLog.Infof(<span class="string">&quot;Push debounce stable[%d] %d: %v since last change, %v since last push, full=%v&quot;</span>,</span><br><span class="line">        pushCounter, debouncedEvents,</span><br><span class="line">        quietTime, eventDelay, req.Full)</span><br><span class="line"></span><br><span class="line">      free = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">go</span> push(req)</span><br><span class="line">      req = <span class="literal">nil</span></span><br><span class="line">      debouncedEvents = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    timeChan = time.After(debounceAfter - quietTime)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到当事件的延迟时间大于等于最大延迟时间或静默时间大于等于最小静默时间，才会执行 push() 方法。 push() 方法也是 <code>debounce</code> 方法中包装的一个过程函数，它会在真正的 <code>pushFn()</code> 完成后向 <code>freeCh</code> 发送消息表示这次防抖处理完成了，可以开始下一次防抖。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">push := <span class="function"><span class="keyword">func</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">  pushFn(req)</span><br><span class="line">  freeCh &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>debounce()</code> 方法等待各个 channel 的逻辑如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> &lt;-freeCh:</span><br><span class="line">    free = <span class="literal">true</span></span><br><span class="line">    pushWorker()</span><br><span class="line">  <span class="keyword">case</span> r := &lt;-ch:</span><br><span class="line">    <span class="comment">// If reason is not set, record it as an unknown reason</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(r.Reason) == <span class="number">0</span> &#123;</span><br><span class="line">      r.Reason = []model.TriggerReason&#123;model.UnknownTrigger&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> !enableEDSDebounce &amp;&amp; !r.Full &#123;</span><br><span class="line">      <span class="comment">// trigger push now, just for EDS</span></span><br><span class="line">      <span class="keyword">go</span> pushFn(r)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lastConfigUpdateTime = time.Now()</span><br><span class="line">    <span class="keyword">if</span> debouncedEvents == <span class="number">0</span> &#123;</span><br><span class="line">      timeChan = time.After(debounceAfter)</span><br><span class="line">      startDebounce = lastConfigUpdateTime</span><br><span class="line">    &#125;</span><br><span class="line">    debouncedEvents++</span><br><span class="line"></span><br><span class="line">    req = req.Merge(r)</span><br><span class="line">  <span class="keyword">case</span> &lt;-timeChan:</span><br><span class="line">    <span class="keyword">if</span> free &#123;</span><br><span class="line">      pushWorker()</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看 <code>case r:= &lt;-ch</code> 这个分支，当收到第一个 PushRequest 的时候，通过一个延时器 <code>timeChan</code> 先延迟一个最小静默时间（100 毫秒），期间接收新的请求直接进行 Merge ，同时累加已防抖的事件个数。当第一个 100 毫秒计时结束就会进入 <code>case &lt;-timeChan</code> 分支，会判断是否有正在执行的防抖过程，没有的话就执行 <code>pushWorker()</code> 做一次防抖判断看是否需要推送。如果第一个请求的延迟时间还没有超过最大延迟时间（10 秒钟）并且距离处理上一次 PushRequest 的时间不足最小静默时间（100 毫秒），则继续延时，等待 <code>debouncedAfter - quietTime</code> 也就是不足最小静默时间的部分，再进行下一次 <code>pushWorker()</code> 操作。</p>
<p>在看真正的 <code>pushFn</code> 函数之前，我们先了解下防抖函数是怎么合并 PushRequest 的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// istio/pilot/pkg/model/push_context.go:250</span></span><br><span class="line"><span class="comment">// Merge two update requests together</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(first *PushRequest)</span> <span class="title">Merge</span><span class="params">(other *PushRequest)</span> *<span class="title">PushRequest</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  merged := &amp;PushRequest&#123;</span><br><span class="line">    <span class="comment">// Keep the first (older) start time</span></span><br><span class="line">    Start: first.Start,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If either is full we need a full push</span></span><br><span class="line">    Full: first.Full || other.Full,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The other push context is presumed to be later and more up to date</span></span><br><span class="line">    Push: other.Push,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge the two reasons. Note that we shouldn&#x27;t deduplicate here, or we would under count</span></span><br><span class="line">    Reason: <span class="built_in">append</span>(first.Reason, other.Reason...),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Do not merge when any one is empty</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(first.ConfigsUpdated) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(other.ConfigsUpdated) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    merged.ConfigsUpdated = <span class="built_in">make</span>(<span class="keyword">map</span>[ConfigKey]<span class="keyword">struct</span>&#123;&#125;, <span class="built_in">len</span>(first.ConfigsUpdated)+<span class="built_in">len</span>(other.ConfigsUpdated))</span><br><span class="line">    <span class="keyword">for</span> conf := <span class="keyword">range</span> first.ConfigsUpdated &#123;</span><br><span class="line">      merged.ConfigsUpdated[conf] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> conf := <span class="keyword">range</span> other.ConfigsUpdated &#123;</span><br><span class="line">      merged.ConfigsUpdated[conf] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合并后的 PushRequest 会保存第一个 PushRequest 的时间以及最新一个 PushRequest 的 <code>PushContext</code> ，如果合并的请求中有一个需要全量推送那合并后的请求也必须是全量， <code>Reason</code> 描述的是触发这次推送请求的原因，有以下几种：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TriggerReason <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  <span class="comment">// Describes a push triggered by an Endpoint change</span></span><br><span class="line">  EndpointUpdate TriggerReason = <span class="string">&quot;endpoint&quot;</span></span><br><span class="line">  <span class="comment">// Describes a push triggered by a config (generally and Istio CRD) change.</span></span><br><span class="line">  ConfigUpdate TriggerReason = <span class="string">&quot;config&quot;</span></span><br><span class="line">  <span class="comment">// Describes a push triggered by a Service change</span></span><br><span class="line">  ServiceUpdate TriggerReason = <span class="string">&quot;service&quot;</span></span><br><span class="line">  <span class="comment">// Describes a push triggered by a change to an individual proxy (such as label change)</span></span><br><span class="line">  ProxyUpdate TriggerReason = <span class="string">&quot;proxy&quot;</span></span><br><span class="line">  <span class="comment">// Describes a push triggered by a change to global config, such as mesh config</span></span><br><span class="line">  GlobalUpdate TriggerReason = <span class="string">&quot;global&quot;</span></span><br><span class="line">  <span class="comment">// Describes a push triggered by an unknown reason</span></span><br><span class="line">  UnknownTrigger TriggerReason = <span class="string">&quot;unknown&quot;</span></span><br><span class="line">  <span class="comment">// Describes a push triggered for debugging</span></span><br><span class="line">  DebugTrigger TriggerReason = <span class="string">&quot;debug&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里做一个小的拓展：追踪上面所有的原因，可以查询到所有可能发送到 <code>pushChannel</code> 的来源：</p>
<p><img src="/images/push-channel-source.png" alt="PushChannel Source"></p>
<p>而 <code>ConfigsUpdated</code> 跟踪了所有已经发生变化的配置，这个 Map 主要被用于那些被 <a target="_blank" rel="noopener" href="https://istio.io/latest/docs/reference/config/networking/sidecar/">Sidecar</a> 限定了服务可见性的数据面代理，来过滤不必接收的 xDS 推送。只有与这些代理相关的服务（如 Sidecar 中定义的 Egress 和 Ingress ）发生变化时，才推送到特定的客户端。当 <code>ConfigsUpdated</code> 为空时，则表示所有的数据面代理都会收到这次推送。</p>
<p>所以才有上面代码中 <code>if len(first.ConfigsUpdated) &gt; 0 &amp;&amp; len(other.ConfigsUpdated) &gt; 0</code> 这个判断，只要有一个请求需要推送至所有代理，就不会合并 <code>ConfigUpdated</code> 。</p>
<p>对 PushRequest 做完防抖之后，再来看真正的 <code>pushFn</code> :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Push is called to push changes on config updates using ADS. This is set in DiscoveryService.Push,</span></span><br><span class="line"><span class="comment">// to avoid direct dependencies.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Push</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> !req.Full &#123;</span><br><span class="line">    req.Push = s.globalPushContext()</span><br><span class="line">    <span class="keyword">go</span> s.AdsPushAll(versionInfo(), req)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  oldPushContext := s.globalPushContext()</span><br><span class="line">  <span class="keyword">if</span> oldPushContext != <span class="literal">nil</span> &#123;</span><br><span class="line">    oldPushContext.OnConfigChange()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  push, err := s.initPushContext(req, oldPushContext)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  req.Push = push</span><br><span class="line">  <span class="keyword">go</span> s.AdsPushAll(versionLocal, req)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到先处理了不是全量推送的请求 <code>if !req.Full</code> ，结合之前分析所有 PushRequest 的来源可知， <code>Full=false</code> 只在 <code>EDSUpdate</code> 的时候才有可能推送，还记得之前分析 <code>ServiceEntryStore</code> 里的 <code>workloadEntryHandler</code> 吗？ EDS 的变化不需要更新 <code>PushContext</code> ，所以这里获取了全局的 <code>globalPushContext</code> 后就直接处理了。说到这里读者可能会对 <code>PushContext</code> 感到疑惑，这个是用来做什么的呢，为什么 EDS 的增量更新就不用更新它呢？我们先来看看 <code>PushContext</code> 的定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PushContext <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// privateServices are reachable within the same namespace, with exportTo &quot;.&quot;</span></span><br><span class="line">  privateServicesByNamespace <span class="keyword">map</span>[<span class="keyword">string</span>][]*Service</span><br><span class="line">  <span class="comment">// publicServices are services reachable within the mesh with exportTo &quot;*&quot;</span></span><br><span class="line">  publicServices []*Service</span><br><span class="line">  <span class="comment">// servicesExportedToNamespace are services that were made visible to this namespace</span></span><br><span class="line">  <span class="comment">// by an exportTo explicitly specifying this namespace.</span></span><br><span class="line">  servicesExportedToNamespace <span class="keyword">map</span>[<span class="keyword">string</span>][]*Service</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ServiceByHostnameAndNamespace has all services, indexed by hostname then namespace.</span></span><br><span class="line">  ServiceByHostnameAndNamespace <span class="keyword">map</span>[host.Name]<span class="keyword">map</span>[<span class="keyword">string</span>]*Service <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">  ServiceByHostname             <span class="keyword">map</span>[host.Name]*Service            <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line">  <span class="comment">// ServiceAccounts contains a map of hostname and port to service accounts.</span></span><br><span class="line">  ServiceAccounts <span class="keyword">map</span>[host.Name]<span class="keyword">map</span>[<span class="keyword">int</span>][]<span class="keyword">string</span> <span class="string">`json:&quot;-&quot;`</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// VirtualService related</span></span><br><span class="line">  <span class="comment">// This contains all virtual services visible to this namespace extracted from</span></span><br><span class="line">  <span class="comment">// exportTos that explicitly contained this namespace. The keys are namespace,gateway.</span></span><br><span class="line">  virtualServicesExportedToNamespaceByGateway <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]Config</span><br><span class="line">  <span class="comment">// this contains all the virtual services with exportTo &quot;.&quot; and current namespace. The keys are namespace,gateway.</span></span><br><span class="line">  privateVirtualServicesByNamespaceAndGateway <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>][]Config</span><br><span class="line">  <span class="comment">// This contains all virtual services whose exportTo is &quot;*&quot;, keyed by gateway</span></span><br><span class="line">  publicVirtualServicesByGateway <span class="keyword">map</span>[<span class="keyword">string</span>][]Config</span><br><span class="line"></span><br><span class="line">  <span class="comment">// destination rules are of three types:</span></span><br><span class="line">  <span class="comment">//  namespaceLocalDestRules: all public/private dest rules pertaining to a service defined in a given namespace</span></span><br><span class="line">  <span class="comment">//  exportedDestRulesByNamespace: all dest rules pertaining to a service exported by a namespace</span></span><br><span class="line">  namespaceLocalDestRules      <span class="keyword">map</span>[<span class="keyword">string</span>]*processedDestRules</span><br><span class="line">  exportedDestRulesByNamespace <span class="keyword">map</span>[<span class="keyword">string</span>]*processedDestRules</span><br><span class="line"></span><br><span class="line">  <span class="comment">// sidecars for each namespace</span></span><br><span class="line">  sidecarsByNamespace <span class="keyword">map</span>[<span class="keyword">string</span>][]*SidecarScope</span><br><span class="line">  <span class="comment">// envoy filters for each namespace including global config namespace</span></span><br><span class="line">  envoyFiltersByNamespace <span class="keyword">map</span>[<span class="keyword">string</span>][]*EnvoyFilterWrapper</span><br><span class="line">  <span class="comment">// gateways for each namespace</span></span><br><span class="line">  gatewaysByNamespace <span class="keyword">map</span>[<span class="keyword">string</span>][]Config</span><br><span class="line">  allGateways         []Config</span><br></pre></td></tr></table></figure>

<p><code>PushContext</code> 里定义了大量对 Service 、 VirtualService 等的缓存，当服务发生变化时，必须要更新，而 EDS 的增量推送则不用。</p>
<p>在 <code>Push()</code> 方法更新了 <code>PushContext</code> 之后便调用 <code>AdsPushAll()</code> 和 <code>startPush(req)</code> 将 PushRequest 重新入队到了 <code>DiscoveryServer.pushQueue</code> :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Send a signal to all connections, with a push event.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">startPush</span><span class="params">(req *model.PushRequest)</span></span> &#123;</span><br><span class="line">  pending := []*Connection&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> _, v := <span class="keyword">range</span> s.adsClients &#123;</span><br><span class="line">    pending = <span class="built_in">append</span>(pending, v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  req.Start = time.Now()</span><br><span class="line">  <span class="keyword">for</span> _, p := <span class="keyword">range</span> pending &#123;</span><br><span class="line">    s.pushQueue.Enqueue(p, req)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PushQueue</code> 的结构是什么样的呢？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> PushQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">  mu   *sync.RWMutex</span><br><span class="line">  cond *sync.Cond</span><br><span class="line"></span><br><span class="line">  <span class="comment">// eventsMap stores all connections in the queue. If the same connection is enqueued again, the</span></span><br><span class="line">  <span class="comment">// PushEvents will be merged.</span></span><br><span class="line">  eventsMap <span class="keyword">map</span>[*Connection]*model.PushRequest</span><br><span class="line"></span><br><span class="line">  <span class="comment">// connections maintains ordering of the queue</span></span><br><span class="line">  connections []*Connection</span><br><span class="line"></span><br><span class="line">  <span class="comment">// inProgress stores all connections that have been Dequeue(), but not MarkDone().</span></span><br><span class="line">  <span class="comment">// The value stored will be initially be nil, but may be populated if the connection is Enqueue().</span></span><br><span class="line">  <span class="comment">// If model.PushRequest is not nil, it will be Enqueued again once MarkDone has been called.</span></span><br><span class="line">  inProgress <span class="keyword">map</span>[*Connection]*model.PushRequest</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>eventsMap</code> 保存了所有代理 gRPC 连接的 PushRequest ，如果相同连接的 PushRequest 再次入队，将会被合并。 <code>inProgress</code> 保存了所有连接正在处理的 PushRequest 。这里合并的操作和上面 <code>debounce</code> 逻辑一样，调用的是同一个函数。</p>
<h3 id="Send-Pushes"><a href="#Send-Pushes" class="headerlink" title="Send Pushes"></a>Send Pushes</h3><p>当所有的 PushRequest 经过防抖等一系列处理后，重新入队到 <code>pushQueue</code> ，这时在 <code>EnvoyXdsServer</code> 启动时创建的协程 <code>sendPushes</code> 就开始工作了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Start</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  adsLog.Infof(<span class="string">&quot;Starting ADS server&quot;</span>)</span><br><span class="line">  <span class="keyword">go</span> s.handleUpdates(stopCh)</span><br><span class="line">  <span class="keyword">go</span> s.periodicRefreshMetrics(stopCh)</span><br><span class="line">  <span class="keyword">go</span> s.sendPushes(stopCh)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">sendPushes</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  doSendPushes(stopCh, s.concurrentPushLimit, s.pushQueue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入了节流的参数 <code>s.concurrentPushLimit</code> ，它是由环境变量 <code>PILOT_PUSH_THROTTLE</code> 控制的，默认为 100 。 <code>doSendPushes</code> 的逻辑如图：</p>
<p><img src="/images/envoyxdsserver-sendpushes.png" alt="EnvoyXdsServer Send Pushes"></p>
<p>首先从 <code>pushQueue</code> 中通过 <code>Dequeue()</code> 方法获取需要处理的代理客户端和对应的 PushRequest ，再根据 PushRequest 生成 Event 传入客户端的 <code>pushChannel</code> 中，注意和 <code>EnvoyXdsServer</code> 的 <code>pushChannel</code> 不同，这里的是针对当前客户端连接的 <code>pushChannel</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doSendPushes</span><span class="params">(stopCh &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, semaphore <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, queue *PushQueue)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      semaphore &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"></span><br><span class="line">      client, info := queue.Dequeue()</span><br><span class="line"></span><br><span class="line">      doneFunc := <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        queue.MarkDone(client)</span><br><span class="line">        &lt;-semaphore</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        pushEv := &amp;Event&#123;</span><br><span class="line">          full:           info.Full,</span><br><span class="line">          push:           info.Push,</span><br><span class="line">          done:           doneFunc,</span><br><span class="line">          start:          info.Start,</span><br><span class="line">          configsUpdated: info.ConfigsUpdated,</span><br><span class="line">          noncePrefix:    info.Push.Version,</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> client.pushChannel &lt;- pushEv:</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">case</span> &lt;-client.stream.Context().Done(): <span class="comment">// grpc stream was closed</span></span><br><span class="line">          doneFunc()</span><br><span class="line">          adsLog.Infof(<span class="string">&quot;Client closed connection %v&quot;</span>, client.ConID)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>client.stream</code> 返回 gRPC 完成的消息后，标记此次 PushRequest 完成。那么这里传入的 <code>pushEv</code> 事件最后在哪里处理了呢？回想最初客户端创建 gRPC 连接的地方，即调用 <code>StreamAggregatedResources()</code> 方法时：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// istio/pilot/pkg/xds/ads.go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">StreamAggregatedResources</span><span class="params">(stream discovery.AggregatedDiscoveryService_StreamAggregatedResourcesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  con := newConnection(peerAddr, stream)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> receiveError error</span><br><span class="line">  reqChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> *discovery.DiscoveryRequest, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> s.receiveThread(con, reqChannel, &amp;receiveError)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="keyword">select</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> req, ok := &lt;-reqChannel:</span><br><span class="line">      <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="keyword">return</span> receiveError</span><br><span class="line">      &#125;</span><br><span class="line">      err := s.processRequest(req, con)</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> pushEv := &lt;-con.pushChannel:</span><br><span class="line">      err := s.pushConnection(con, pushEv)</span><br><span class="line">      pushEv.done()</span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里处理了两个 channel 的消息，一个是 <code>reqChannel</code> ，另一个就是我们刚提到的 <code>con.pushChannel</code> 了。 <code>reqChannel</code> 之后再讨论，它主要是处理来自客户端的 gRPC 请求的。</p>
<p>从 <code>con.pushConnection</code> 中获取到 <code>pushEv</code> 事件后，调用 <code>s.pushConnection()</code> 进行处理。首先会处理增量推送 EDS 的情况：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> !pushEv.full &#123;</span><br><span class="line">  <span class="keyword">if</span> !ProxyNeedsPush(con.node, pushEv) &#123;</span><br><span class="line">    adsLog.Debugf(<span class="string">&quot;Skipping EDS push to %v, no updates required&quot;</span>, con.ConID)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  edsUpdatedServices := model.ConfigNamesOfKind(pushEv.configsUpdated, gvk.ServiceEntry)</span><br><span class="line">  <span class="comment">// Push only EDS. This is indexed already - push immediately</span></span><br><span class="line">  <span class="comment">// (may need a throttle)</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(con.Clusters()) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(edsUpdatedServices) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := s.pushEds(pushEv.push, con, versionInfo(), edsUpdatedServices); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>ProxyNeedsPush</code> 判断代理是否需要推送，判断的逻辑主要是检查推送事件 <code>pushEv</code> 的 <code>configsUpdated</code> 是否和代理相关。之前提到的在大规模下发场景下起很大作用的 <a target="_blank" rel="noopener" href="https://istio.io/latest/docs/reference/config/networking/sidecar/">Sidecar</a> 就在这里生效。注意这里说的是 Istio 的一种流控配置，不是数据面的边车模式。</p>
<ol>
<li><p>SidecarScope</p>
<p>书接上文，我们着重分析下 <code>SidecarScope</code> 的处理流程。这里接着看是怎么检测代理依赖的配置文件的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">checkProxyDependencies</span><span class="params">(proxy *model.Proxy, config model.ConfigKey)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// Detailed config dependencies check.</span></span><br><span class="line">  <span class="keyword">switch</span> proxy.Type &#123;</span><br><span class="line">  <span class="keyword">case</span> model.SidecarProxy:</span><br><span class="line">    <span class="keyword">if</span> proxy.SidecarScope.DependsOnConfig(config) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> proxy.PrevSidecarScope != <span class="literal">nil</span> &amp;&amp; proxy.PrevSidecarScope.DependsOnConfig(config) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// TODO We&#x27;ll add the check for other proxy types later.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SidecarScope.DependsOnConfig()</code> 方法内容如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DependsOnConfig determines if the proxy depends on the given config.</span></span><br><span class="line"><span class="comment">// Returns whether depends on this config or this kind of config is not scoped(unknown to be depended) here.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *SidecarScope)</span> <span class="title">DependsOnConfig</span><span class="params">(config ConfigKey)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> sc == <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This kind of config will trigger a change if made in the root namespace or the same namespace</span></span><br><span class="line">  <span class="keyword">if</span> _, f := sidecarScopeNamespaceConfigTypes[config.Kind]; f &#123;</span><br><span class="line">    <span class="keyword">return</span> config.Namespace == sc.RootNamespace || config.Namespace == sc.Config.Namespace</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This kind of config is unknown to sidecarScope.</span></span><br><span class="line">  <span class="keyword">if</span> _, f := sidecarScopeKnownConfigTypes[config.Kind]; !f &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _, exists := sc.configDependencies[config.HashCode()]</span><br><span class="line">  <span class="keyword">return</span> exists</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它先是判断了变化的配置是否和 <code>SidecarScope</code> 是同个命名空间，不过这只针对 Sidecar 和 EnvoyFilter 等特殊配置。再处理一些不常见的配置，如果这些配置不在 <code>SidecarScope</code> 管理范围内的话，作为 unknown 类型也返回 true 。 <code>SidecarScope</code> 管理的流控配置主要是以下三种：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">sidecarScopeKnownConfigTypes = <span class="keyword">map</span>[resource.GroupVersionKind]<span class="keyword">struct</span>&#123;&#125;&#123;</span><br><span class="line">  gvk.ServiceEntry:    &#123;&#125;,</span><br><span class="line">  gvk.VirtualService:  &#123;&#125;,</span><br><span class="line">  gvk.DestinationRule: &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>处理完了特殊情况，就会检测上面三种流控配置是否与当前的代理有关联：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, exists := sc.configDependencies[config.HashCode()]</span><br><span class="line"><span class="keyword">return</span> exists</span><br></pre></td></tr></table></figure>

<p><code>configDependencies</code> 里保存的就是跟当前代理相关的所有流控配置，它是在初始化代理时创建的。还记得当数据面代理第一次连接至控制面时 <code>StreamAggregatedResources()</code> 方法里创建的 <code>receiveThread</code> 协程吗？</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">StreamAggregatedResources</span><span class="params">(stream discovery.AggregatedDiscoveryService_StreamAggregatedResourcesServer)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  con := newConnection(peerAddr, stream)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> receiveError error</span><br><span class="line">  reqChannel := <span class="built_in">make</span>(<span class="keyword">chan</span> *discovery.DiscoveryRequest, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> s.receiveThread(con, reqChannel, &amp;receiveError)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>receiveThread</code> 里有个 <code>initConnection</code> 方法：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">receiveThread</span><span class="params">(con *Connection, reqChannel <span class="keyword">chan</span> *discovery.DiscoveryRequest, errP *error)</span></span> &#123;</span><br><span class="line">  firstReq := <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> firstReq &#123;</span><br><span class="line">      firstReq = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">if</span> err := s.initConnection(req.Node, con); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        *errP = err</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initConnection</code> 刚开始就会做 <code>initProxy</code> 的操作初始化代理，中间会设置代理的状态：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initProxy initializes the Proxy from node.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">initProxy</span><span class="params">(node *core.Node)</span> <span class="params">(*model.Proxy, error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> err = s.setProxyState(proxy, s.globalPushContext()); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> proxy, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里就能看到它在设置 <code>SidecarScope</code> 了：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">setProxyState</span><span class="params">(proxy *model.Proxy, push *model.PushContext)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> err := proxy.SetWorkloadLabels(s.Env); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err := proxy.SetServiceInstances(push.ServiceDiscovery); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  proxy.SetSidecarScope(push)</span><br><span class="line">  proxy.SetGatewaysForProxy(push)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果代理是 <code>SidecarProxy</code> 的话（其他还有诸如 <code>Gateway</code> 等模式）,调用 <code>PushContext.getSidecarScope</code> 初始化 <code>SidecarScope</code> :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(node *Proxy)</span> <span class="title">SetSidecarScope</span><span class="params">(ps *PushContext)</span></span> &#123;</span><br><span class="line">  sidecarScope := node.SidecarScope</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> node.Type == SidecarProxy &#123;</span><br><span class="line">    workloadLabels := labels.Collection&#123;node.Metadata.Labels&#125;</span><br><span class="line">    node.SidecarScope = ps.getSidecarScope(node, workloadLabels)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Gateways should just have a default scope with egress: */*</span></span><br><span class="line">    node.SidecarScope = DefaultSidecarScopeForNamespace(ps, node.ConfigNamespace)</span><br><span class="line">  &#125;</span><br><span class="line">  node.PrevSidecarScope = sidecarScope</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 <code>PushContext</code> 里保存了当前这次推送所用到的所有上下文，通过 <code>PushContext.sidecarsByNamespace</code> 就能拿到当前代理所在命名空间的所有 Sidecar 配置。再检查当前代理所依附的实例的 Labels 是否符合 Sidecar 定义的 workloadSelector :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ps *PushContext)</span> <span class="title">getSidecarScope</span><span class="params">(proxy *Proxy, workloadLabels labels.Collection)</span> *<span class="title">SidecarScope</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> sidecars, ok := ps.sidecarsByNamespace[proxy.ConfigNamespace]; ok &#123;</span><br><span class="line">    <span class="keyword">var</span> defaultSidecar *SidecarScope</span><br><span class="line">    <span class="keyword">for</span> _, wrapper := <span class="keyword">range</span> sidecars &#123;</span><br><span class="line">      <span class="keyword">if</span> wrapper.Config != <span class="literal">nil</span> &amp;&amp; wrapper.Config.Spec != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">if</span> sidecar.GetWorkloadSelector() != <span class="literal">nil</span> &#123;</span><br><span class="line">          workloadSelector := labels.Instance(sidecar.GetWorkloadSelector().GetLabels())</span><br><span class="line">          <span class="keyword">if</span> !workloadLabels.IsSupersetOf(workloadSelector) &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> wrapper</span><br><span class="line">        &#125;</span><br><span class="line">        defaultSidecar = wrapper</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Not sure when this can happen (Config = nil ?)</span></span><br><span class="line">      <span class="keyword">if</span> defaultSidecar != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultSidecar <span class="comment">// still return the valid one</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> defaultSidecar != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> defaultSidecar <span class="comment">// still return the valid one</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> DefaultSidecarScopeForNamespace(ps, proxy.ConfigNamespace)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时就把 <code>SidecarScope</code> 和 Proxy 关联起来了，这里的 <code>SidecarScope</code> 已经是 <code>PushContext</code> 处理过的了，里面 <code>configDependencies</code> 都是有值的。这个值是在哪里设置的呢？在 <code>InitContext</code> 的时候，有个 <code>PushContext.initSidecarScope()</code> 方法，这个方法就是解析 Sidecar 里的具体内容，调用 <code>ConvertToSidecarScope</code> 将 Engress 和 Ingress 里的定义的服务找出来后，逐个调用 <code>AddConfigDependencies</code> 写入 <code>configuDependencies</code> 中。</p>
<p><code>ConvertToSidecarScope</code> 函数的代码位于 <code>istio/pilot/pkg/model/sidecar.go:226</code> 中，限于篇幅，感兴趣的读者可以自行研读。</p>
<p>到这里 <code>SidecarScope</code> 的整个处理流程就处理完了，在生产环境中运用好 <code>SidecarScope</code> 能极大的减小数据面收到的 xDS 的数量，希望这段代码分析能帮助各位读者更好的理解，在实际运用过程中可以更好的定位问题。</p>
</li>
<li><p>PushConnection</p>
<p>回到 <code>pushConnection</code> 的主流程，在 <code>Full=false</code> 下判断 <code>ProxyNeedsPush</code> ，确定需要推送后调用 <code>pushEds</code> 增量推送 EDS 。</p>
<p>详细分析下 <code>pushEds</code> 的过程，首先遍历所有的 Clusters ，构建生成器生成 EDS ，然后调用 con.send() 进行推送：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">pushEds</span><span class="params">(push *model.PushContext, con *Connection, version <span class="keyword">string</span>, edsUpdatedServices <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">for</span> _, clusterName := <span class="keyword">range</span> con.Clusters() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    builder := createEndpointBuilder(clusterName, con.node, push)</span><br><span class="line">    l := s.generateEndpoints(builder)</span><br><span class="line">    <span class="keyword">if</span> l == <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, e := <span class="keyword">range</span> l.Endpoints &#123;</span><br><span class="line">      endpoints += <span class="built_in">len</span>(e.LbEndpoints)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l.Endpoints) == <span class="number">0</span> &#123;</span><br><span class="line">      empty++</span><br><span class="line">    &#125;</span><br><span class="line">    loadAssignments = <span class="built_in">append</span>(loadAssignments, l)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  response := endpointDiscoveryResponse(loadAssignments, version, push.Version, con.node.RequestedTypes.EDS)</span><br><span class="line">  err := con.send(response)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后调用 <code>conn.steam.Send()</code> 就将 EDS 发送至数据面的客户端了。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Send with timeout</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(conn *Connection)</span> <span class="title">send</span><span class="params">(res *discovery.DiscoveryResponse)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  done := <span class="built_in">make</span>(<span class="keyword">chan</span> error, <span class="number">1</span>)</span><br><span class="line">  t := time.NewTimer(SendTimeout)</span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    err := conn.stream.Send(res)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    done &lt;- err</span><br><span class="line">  &#125;()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是增量推送的话这里就退出了，全量推送和只推送 EDS 一样，也会先判断下 <code>ProxyNeedsPush</code> ，确定需要后开始全量推送，根据 <code>pushTypes</code> 的不同分别推送 CDS 、 EDS 、 LDS 和 RDS :</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">pushTypes := PushTypeFor(con.node, pushEv)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> con.Watching(v3.ClusterShortType) &amp;&amp; pushTypes[CDS] &#123;</span><br><span class="line">  err := s.pushCds(con, pushEv.push, currentVersion)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.StatusReporter != <span class="literal">nil</span> &#123;</span><br><span class="line">  s.StatusReporter.RegisterEvent(con.ConID, ClusterEventType, pushEv.noncePrefix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(con.Clusters()) &gt; <span class="number">0</span> &amp;&amp; pushTypes[EDS] &#123;</span><br><span class="line">  err := s.pushEds(pushEv.push, con, currentVersion, <span class="literal">nil</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.StatusReporter != <span class="literal">nil</span> &#123;</span><br><span class="line">  s.StatusReporter.RegisterEvent(con.ConID, EndpointEventType, pushEv.noncePrefix)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> con.Watching(v3.ListenerShortType) &amp;&amp; pushTypes[LDS] &#123;</span><br><span class="line">  err := s.pushLds(con, pushEv.push, currentVersion)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.StatusReporter != <span class="literal">nil</span> &#123;</span><br><span class="line">  s.StatusReporter.RegisterEvent(con.ConID, ListenerEventType, pushEv.noncePrefix)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(con.Routes()) &gt; <span class="number">0</span> &amp;&amp; pushTypes[RDS] &#123;</span><br><span class="line">  err := s.pushRoute(con, pushEv.push, currentVersion)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> s.StatusReporter != <span class="literal">nil</span> &#123;</span><br><span class="line">  s.StatusReporter.RegisterEvent(con.ConID, RouteEventType, pushEv.noncePrefix)</span><br><span class="line">&#125;</span><br><span class="line">proxiesConvergeDelay.Record(time.Since(pushEv.start).Seconds())</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<p>推送的逻辑和 EDS 一样，这里就不再赘述。至此，所有 xDS 的下发就完成了。</p>
</li>
</ol>
<h3 id="Client-Request"><a href="#Client-Request" class="headerlink" title="Client Request"></a>Client Request</h3><p>这部分的内容比较简单，核心推送和上面的 <code>sendPushes</code> 一样，流程先是从 <code>reqChannel</code> 中获取 <code>DiscoveryRequest</code> 看客户端订阅了哪些 xDS ，组装推送即可。</p>
<p><img src="/images/envoyxdsserver-client-requests.png" alt="EnvoyXdsServer Client Request"></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">processRequest</span><span class="params">(discReq *discovery.DiscoveryRequest, con *Connection)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">switch</span> discReq.TypeUrl &#123;</span><br><span class="line">  <span class="keyword">case</span> v2.ClusterType, v3.ClusterType:</span><br><span class="line">    <span class="keyword">if</span> err := s.handleTypeURL(discReq.TypeUrl, &amp;con.node.RequestedTypes.CDS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := s.handleCds(con, discReq); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> v2.ListenerType, v3.ListenerType:</span><br><span class="line">    <span class="keyword">if</span> err := s.handleTypeURL(discReq.TypeUrl, &amp;con.node.RequestedTypes.LDS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := s.handleLds(con, discReq); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> v2.RouteType, v3.RouteType:</span><br><span class="line">    <span class="keyword">if</span> err := s.handleTypeURL(discReq.TypeUrl, &amp;con.node.RequestedTypes.RDS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := s.handleRds(con, discReq); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">case</span> v2.EndpointType, v3.EndpointType:</span><br><span class="line">    <span class="keyword">if</span> err := s.handleTypeURL(discReq.TypeUrl, &amp;con.node.RequestedTypes.EDS); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := s.handleEds(con, discReq); err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    err = s.handleCustomGenerator(con, discReq)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>xDS 的推送流程到这里就讲完了。我们从 <code>EnvoyXdsServer</code> 的结构开始，对其启动流程、怎么与客户端建立连接、怎么感知配置和服务变化、怎么防抖、怎么推送、<code>SidecarScope</code> 如何工作等都做了比较细致的分析，虽然已经阅读了源码，但是距离服务网格化的实际落地、实践中的各种性能问题、针对业务的优化，我们还有很长一段路要走。</p>
<p>限于篇幅， xDS 的生成逻辑我们将在下一篇源码分析中讲解，也就是生成器中构建 xDS 的地方，这部分涉及到很多数据的转化，内容繁杂，需要整篇分析才能讲解的清楚。</p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#EnvoyXdsServer"><span class="toc-number">1.</span> <span class="toc-text">EnvoyXdsServer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Initialization"><span class="toc-number">1.1.</span> <span class="toc-text">Initialization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Receive-Connection"><span class="toc-number">1.2.</span> <span class="toc-text">Receive Connection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Receive-Change"><span class="toc-number">1.3.</span> <span class="toc-text">Receive Change</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Handle-Updates"><span class="toc-number">1.4.</span> <span class="toc-text">Handle Updates</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Send-Pushes"><span class="toc-number">1.5.</span> <span class="toc-text">Send Pushes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Client-Request"><span class="toc-number">1.6.</span> <span class="toc-text">Client Request</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.7.</span> <span class="toc-text">总结</span></a></li></ol></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&text=Istio Pilot 源码分析（三）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&is_video=false&description=Istio Pilot 源码分析（三）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Istio Pilot 源码分析（三）&body=Check out this article: https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&title=Istio Pilot 源码分析（三）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&name=Istio Pilot 源码分析（三）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/&t=Istio Pilot 源码分析（三）"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2021
    zhd173
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-125225753-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'haidongdev';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
