<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="Istio 作为目前 ServiceMesh 方案中的翘楚，吸引着越来越多的企业及开发者。越来越多的团队想将其应用于微服务的治理，但在实际落地时却因为不了解 Istio 黑盒中的运行机制而左右为难，本文将基于 1.7 的源码讲解 Istio 的核心组件 Pilot 的结构及运行流程，希望对读者应用 Istio 有所助益。 注：本文基于 istio release-1.7 分支分析，其他版本的代码结">
<meta property="og:type" content="article">
<meta property="og:title" content="Istio Pilot 源码分析（一）">
<meta property="og:url" content="https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/index.html">
<meta property="og:site_name" content="海东的博客">
<meta property="og:description" content="Istio 作为目前 ServiceMesh 方案中的翘楚，吸引着越来越多的企业及开发者。越来越多的团队想将其应用于微服务的治理，但在实际落地时却因为不了解 Istio 黑盒中的运行机制而左右为难，本文将基于 1.7 的源码讲解 Istio 的核心组件 Pilot 的结构及运行流程，希望对读者应用 Istio 有所助益。 注：本文基于 istio release-1.7 分支分析，其他版本的代码结">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://haidong.dev/images/pilot-discovery-struct.png">
<meta property="og:image" content="https://haidong.dev/images/pilot-discovery-serviceentry.png">
<meta property="og:image" content="https://haidong.dev/images/pilot-discovery-sequence-all.png">
<meta property="og:image" content="https://haidong.dev/images/pilot-discovery-sequence-init.png">
<meta property="og:image" content="https://i.loli.net/2020/09/03/P5eOiE2NwjMxLty.png">
<meta property="og:image" content="https://i.loli.net/2020/09/03/2IbDaBl91TOgNt7.png">
<meta property="article:published_time" content="2020-09-03T02:27:16.000Z">
<meta property="article:modified_time" content="2020-09-30T03:19:15.434Z">
<meta property="article:author" content="zhd173">
<meta property="article:tag" content="cloudnative">
<meta property="article:tag" content="go">
<meta property="article:tag" content="servicemesh">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://haidong.dev/images/pilot-discovery-struct.png">
    
    
        
          
              <link rel="shortcut icon" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=16">
          
        
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=192" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=180">
          
        
    
    <!-- title -->
    <title>Istio Pilot 源码分析（一）</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&text=Istio Pilot 源码分析（一）"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&is_video=false&description=Istio Pilot 源码分析（一）"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Istio Pilot 源码分析（一）&body=Check out this article: https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&name=Istio Pilot 源码分析（一）&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&t=Istio Pilot 源码分析（一）"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E8%A7%82%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">宏观架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">启动流程梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">初始化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        Istio Pilot 源码分析（一）
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">海东的博客</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2020-09-03T02:27:16.000Z" itemprop="datePublished">2020-09-03</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/cloudnative/" rel="tag">cloudnative</a>, <a class="tag-link-link" href="/tags/go/" rel="tag">go</a>, <a class="tag-link-link" href="/tags/servicemesh/" rel="tag">servicemesh</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <p><code>Istio</code> 作为目前 <code>ServiceMesh</code> 方案中的翘楚，吸引着越来越多的企业及开发者。越来越多的团队想将其应用于微服务的治理，但在实际落地时却因为不了解 <code>Istio</code> 黑盒中的运行机制而左右为难，本文将基于 1.7 的源码讲解 <code>Istio</code> 的核心组件 <code>Pilot</code> 的结构及运行流程，希望对读者应用 <code>Istio</code> 有所助益。</p>
<p><em>注：本文基于 <code>istio release-1.7</code> 分支分析，其他版本的代码结构会有所不同。</em></p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>随着 <code>Istio</code> 1.7 的发布，内部组件精简后的 <code>istiod</code> 日趋稳定，越来越多的公司将其应用到自身微服务的流量治理、安全通信及监测中。多点也不例外，应用 <code>Istio</code> 来落地业务系统所有 <code>Dubbo</code> 服务的网格化，下沉 <code>SDK</code> 逻辑，解决基础中间件与业务系统过于耦合等痛点。 目前，我们是通过自己开发的 <code>Controller</code> 组件对接 <code>Zookeeper</code> 等注册中心，将注册到 <code>Zookeeper</code> 的节点实时转化为 <code>ServiceEntry</code> 及 <code>WorkloadEntry</code> 等 <code>Istio</code> 配置类型写入 <code>kube-apiserver</code>，再由 <code>Pilot</code> 转化为 <code>xDS</code> 协议下发至数据面，同时对集群、虚拟机中的服务进行治理。随着公司服务网格化的逐步落地，对 <code>Istio</code> 及数据面组件源码级掌握的诉求越来越高，没有足够的深度及广度很难解决开发过程中遇到的难题，让我们一起揭开 <code>Istio</code> 神秘的面纱，看看黑箱内部是如何运作的。</p>
<p>本文作为 <code>Istio</code> 控制面组件 <code>Pilot</code> 的源码分析系列，主要面向刚接触 <code>Istio</code> 或仅停留在使用 <code>Istio</code> 基本配置类型（如 <code>VirtualService</code>、<code>DestinationRule</code> 等）的同学，需要熟悉 <code>Istio</code> 的一些 <a target="_blank" rel="noopener" href="https://istio.io/latest/zh/docs/concepts/traffic-management/">基础概念及名词</a> 。文章会涉及较多的代码细节，我们会以不同的篇幅分别介绍以下内容：</p>
<ol>
<li><code>pilot-discovery</code> 宏观架构及启动流程梳理</li>
<li><code>pilot-discovery</code> 接口设计及关键接口分析</li>
<li><code>pilot-discovery xDS</code> 生成及下发流程梳理</li>
<li><code>pilot-agent</code> 流程梳理</li>
<li><code>pilot</code> 中的身份认证及安全通信解析</li>
</ol>
<p>相信通过源码一步一步分析，能消除读者对 <code>Pilot</code> 的陌生感，在基于 <code>Pilot</code> 做适配开发时会更加清楚的了解其底层运行逻辑，碰到问题时也能更好的定位。</p>
<p><code>Pilot</code> 的代码主要分为两部分: </p>
<ul>
<li><code>pilot-discovery</code></li>
<li><code>pilot-agent</code></li>
</ul>
<p>其中 <code>pilot-agent</code> 负责数据面 <code>Sidecar</code> 实例的生命周期管理，而 <code>pilot-discovery</code> 负责控制面流量管理配置及路由规则的生成和下发。</p>
<h2 id="宏观架构"><a href="#宏观架构" class="headerlink" title="宏观架构"></a>宏观架构</h2><p><code>pilot-discovery</code> 的核心组件如图：<br><img src="/images/pilot-discovery-struct.png" alt="pilot-discovery-struct"></p>
<p>其中 <code>Server</code> 为 <code>pilot-discovery</code> 的主服务，包含了三个比较重要的组件：</p>
<ul>
<li><code>Config Controller</code>：从不同来源接收流量控制和路由规则等 <code>Istio</code> 的配置，并响应各类事件。</li>
<li><code>Service Controller</code>：从不同注册中心同步服务及实例，并响应各类事件。</li>
<li><code>EnvoyXdsServer</code>：核心的 <code>xDS</code> 协议推送服务，根据上面组件的数据生成 <code>xDS</code> 协议并下发。</li>
</ul>
<p><code>Config Controller</code> 比较核心的就是对接 <code>Kubernetes</code>，从 <code>kube-apiserver</code> 中 <code>Watch</code> 集群中的 <code>VirtualService</code>、<code>ServiceEntry</code>、<code>DestinationRules</code> 等配置信息，有变化则生成 <code>PushRequest</code> 推送至 <code>EnvoyXdsServer</code> 中的推送队列。除此之外，还支持对接 <code>MCP(Mesh Configuration Protocol)</code> 协议的 <code>gRPC Server</code>，如 <code>Nacos</code> 的 <code>MCP</code> 服务等，只需要在 <code>meshconfig</code> 中配置 <code>configSources</code> 即可。最后一种是基于内存的 <code>Config Controller</code> 实现，通过 <code>Watch</code> 一个文件目录，加载目录中的 <code>yaml</code> 文件生成配置数据，主要用来测试。</p>
<p><code>Service Controller</code> 目前原生支持 <code>Kubernetes</code> 和 <code>Consul</code>，注册在这些注册中心中的服务可以无痛接入 <code>Mesh</code>，另外一种比较特殊，就是 <code>ServiceEntryStore</code>，它本质是储存在 <code>Config Controller</code> 中的 <code>Istio</code> 配置数据，但它描述的却是集群外部的服务信息，详情可阅读文档 <a target="_blank" rel="noopener" href="https://istio.io/latest/docs/reference/config/networking/service-entry/">ServiceEntry</a>，<code>Istio</code> 通过它将集群外部，如部署在虚拟机中的服务、非 <code>Kubernetes</code> 的原生服务同步到 <code>Istio</code> 中，纳入网格统一进行流量控制和路由，所以 <code>ServiceEntryStore</code> 也可以视为一种注册中心。还有一种就是 <code>Mock Service Registry</code>，主要用来测试。</p>
<p><code>ServiceEntryStore</code> 从 <code>Config Controller</code> 到 <code>Service Controller</code> 的转化流程大致如图（后续会做详细的代码分析，这里简单了解一下即可）：</p>
<p><img src="/images/pilot-discovery-serviceentry.png" alt="pilot-discovery-serviceentrystore"></p>
<p><code>ConfigStores</code> 是一个列表，里面存储了各类 <code>Istio</code> 配置文件，包括 <code>ServiceEntry</code> 、<code>WorkloadEntry</code> 等服务数据，也包括 <code>VirtualService</code>、<code>DestinationRules</code>、<code>Sidecar</code> 等流量控制、路由规则的配置数据，<code>pilot-discovery</code> 将这些 <code>ConfigStores</code> 聚合成一个 <code>configController</code> 统一进行管理，之后再从其中衍生出 <code>IstioConfigStore</code>，将其作为 <code>serviceEntryStore</code> 的配置源。<code>serviceEntryStore</code> 其实就是 <code>ServiceEntry Controller</code>，响应 <code>ServiceEntry</code> 和 <code>WorkloadEntry</code> 这类服务信息的变化。</p>
<p><code>EnvoyXdsServer</code> 比较核心，一切与 <code>xDS</code> 协议相关的接收、转换、下发操作都由它完成。<code>EnvoyXdsServer</code> 对接所有集群中的边车代理，如 <code>Envoy</code>、<code>MOSN</code> 等，当配置或服务发生变化时主动推送，也会响应代理发送的请求，依据请求的信息下发相应的 <code>xDS</code> 配置。</p>
<p>理解了这三个核心组件的定义，就能比较好的理解下面分析的各类流程了。</p>
<p><code>pilot-discovery</code> 的整个业务流程梳理如下，可以先大概浏览一遍，之后我们逐一进行分析:<br><img src="/images/pilot-discovery-sequence-all.png" alt="pilot-discovery-sequence-all"></p>
<h2 id="启动流程梳理"><a href="#启动流程梳理" class="headerlink" title="启动流程梳理"></a>启动流程梳理</h2><p>首先详细看一下 <code>pilot-discovery</code> 的启动流程。<code>pilot-discovery</code> 组件的入口代码在 <code>istio/pilot/cmd/pilot-discovery</code> 中。该目录中包含两个文件: <code>main.go</code> 和 <code>request.go</code>。<code>main.go</code> 中定义了 <code>pilot-discovery</code> 根命令及 <code>discovery</code> 命令，是启动服务发现及配置下发的主流程; 另一个文件 <code>request.go</code> 中定义了 <code>request</code> 命令，用来请求 <code>Pilot</code> 中的 <code>metrics/debug</code> 接口，多用来调试。</p>
<p><code>main.go</code> 中 <code>discoveryCmd</code>的 <code>RunE</code> 函数定义了启动过程，代码如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建一个接收空结构的 stop channel 用来停止所有 servers</span></span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建服务发现的 Server</span></span><br><span class="line">discoveryServer, err := bootstrap.NewServer(serverArgs)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to create discovery service: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行 Server 中注册的所有服务</span></span><br><span class="line"><span class="keyword">if</span> err := discoveryServer.Start(stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;failed to start discovery service: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待 SIGINT 和 SIGTERM 信号并关闭 stop channel</span></span><br><span class="line">cmd.WaitSignal(stop)</span><br></pre></td></tr></table></figure>

<p>启动流程如图所示：<br><img src="/images/pilot-discovery-sequence-init.png" alt="pilot-discovery-init"></p>
<h3 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h3><p>接下来介绍 <code>discoveryServer</code> ，即 <code>pilot-discovery</code> 组件的核心。在这之前先看下 <code>Server</code> 的结构，代码位于 <code>istio/pilot/pkg/bootstrap/server.go</code> 文件中。</p>
<p><code>Server</code> 的关键字段如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  XDSServer *xds.DiscoveryServer  <span class="comment">// Xds 服务</span></span><br><span class="line">  environment *model.Environment  <span class="comment">// Pilot 环境所需的 API 集合</span></span><br><span class="line">  kubeRegistry *kubecontroller.Controller   <span class="comment">// 处理 Kubernetes 主集群的注册中心</span></span><br><span class="line">  multicluster *kubecontroller.Multicluster <span class="comment">// 处理 Kubernetes 多个集群的注册中心</span></span><br><span class="line">  configController  model.ConfigStoreCache  <span class="comment">// 统一处理配置数据（如 VirtualService 等) 的 Controller</span></span><br><span class="line">  ConfigStores      []model.ConfigStoreCache <span class="comment">// 不同配置信息的缓存器，提供 Get、List、Create 等方法</span></span><br><span class="line">  serviceEntryStore *serviceentry.ServiceEntryStore <span class="comment">// 单独处理 ServiceEntry 的 Controller</span></span><br><span class="line">  fileWatcher filewatcher.FileWatcher <span class="comment">// 文件监听器，主要 watch meshconfig 和 networks 配置文件等</span></span><br><span class="line">  startFuncs []startFunc <span class="comment">// 保存了上述所有服务的启动函数，便于在 Start() 方法中批量启动及管理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看 <code>NewServer()</code> 方法中的内容，有以下几个关键步骤：</p>
<p><img src="https://i.loli.net/2020/09/03/P5eOiE2NwjMxLty.png" alt="image.png"></p>
<p>我们对每个步骤逐一进行分析:</p>
<ol>
<li><p>初始化 <code>Environment</code></p>
<p>什么是 <code>Environment</code> 呢？根据定义 <code>Environment</code> 为 <code>Pilot</code> 提供了一个汇总的、运行中所需的 API 集合。 <code>Environment</code> 中字段（接口）如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Environment <span class="keyword">struct</span> &#123;</span><br><span class="line">  ServiceDiscovery  <span class="comment">// 服务发现的接口模型，主要列出 services 和 instances</span></span><br><span class="line">  IstioConfigStore  <span class="comment">// Istio 配置文件的存储器，主要列出 ServiceEntry 等配置</span></span><br><span class="line">  mesh.Watcher      <span class="comment">// mesh config 文件的监听器</span></span><br><span class="line">  mesh.NetworksWatcher <span class="comment">// mesh network config 文件的监听器</span></span><br><span class="line">  PushContext *PushContext <span class="comment">// 在推送（下发 xDS）生成期间保存信息的上下文</span></span><br><span class="line">  DomainSuffix <span class="keyword">string</span> <span class="comment">// istio server 默认的后缀域名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>PushContext</code> 是 <code>Pilot</code> 在推送 <code>xDS</code> 前，生成配置期间保存相关信息的上下文的地方，在全量推送配置和配置发生改变时重置。它会保存所有的错误和统计信息，并缓存一些配置的计算信息。 <code>ServiceDiscovery</code> 提供了枚举 <code>Istio</code> 中服务和实例的方法。 <code>mesh.Watcher</code> 和 <code>mesh.NetworksWatcher</code> 负责监听 <code>istiod</code> 启动时挂载的两个配置文件，这两个配置文件是通过 <code>configmap</code> 映射到 <code>Pod</code> 的文件系统中的，监听器将在监听到配置文件变化时运行预先注册的 <code>Handler</code> 。文件挂载参考 <code>istiod</code> 的配置文件：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istiod-56c488887d-z9k5c</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="attr">volumeMounts:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/etc/istio/config</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">config-volume</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">configMap:</span></span><br><span class="line">      <span class="attr">defaultMode:</span> <span class="number">420</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">istio</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">config-volume</span></span><br></pre></td></tr></table></figure>

<p>相应的配置存储在 <code>istio-system/istio</code> 这个 <code>configmap</code> 中，里面保存了 <code>mesh</code> 和 <code>meshNetworks</code> 两种配置，样例如下:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">istio</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">istio-system</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">mesh:</span> <span class="string">|-</span></span><br><span class="line">    <span class="attr">accessLogEncoding:</span> <span class="string">TEXT</span></span><br><span class="line">    <span class="attr">accessLogFile:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">accessLogFormat:</span> <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="attr">defaultConfig:</span></span><br><span class="line">      <span class="attr">binaryPath:</span> <span class="string">/usr/local/bin/mosn</span></span><br><span class="line">      <span class="attr">concurrency:</span> <span class="number">2</span></span><br><span class="line">      <span class="attr">configPath:</span> <span class="string">./etc/istio/proxy</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line">  <span class="attr">meshNetworks:</span> <span class="string">&#x27;networks: &#123;&#125;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>再回头看 <code>Environment</code> 的初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">e := &amp;model.Environment&#123;</span><br><span class="line">  PushContext:  model.NewPushContext(),</span><br><span class="line">  DomainSuffix: args.RegistryOptions.KubeOptions.DomainSuffix,</span><br><span class="line">&#125;</span><br><span class="line">ac := aggregate.NewController(aggregate.Options&#123;</span><br><span class="line">  MeshHolder: e,</span><br><span class="line">&#125;)</span><br><span class="line">e.ServiceDiscovery = ac</span><br></pre></td></tr></table></figure>

<p>首先是初始化了一份 <code>PushContext</code> ，创建 <code>PushContext</code> 所需的各种列表和 <code>Map</code> 。 其次是初始化了一个聚合所有注册中心的 <code>Controller</code> 作为 <code>Environment</code> 中的 <code>ServiceDiscovery</code> 。 该 <code>Controller</code> 提供从所有注册中心（如 <code>Kubernetes, Consul, MCP</code> 等）获取服务和实例列表的方法。 这里传入了一个参数 <code>MeshHolder</code> 是想利用 <code>Environment</code> 中的 <code>mesh.Watcher</code> 将 <code>mesh</code> 这个配置同步过去。</p>
</li>
<li><p>初始化 <code>Server</code></p>
<p><code>Server</code> 的结构之前分析过，这里将之前初始化的 <code>Environment</code> 传入后，开始初始化 <code>XDSServer</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s := &amp;Server&#123;</span><br><span class="line">  clusterID:       getClusterID(args),</span><br><span class="line">  environment:     e,</span><br><span class="line">  XDSServer:       xds.NewDiscoveryServer(e, args.Plugins), <span class="comment">// 初始化 XDSServer</span></span><br><span class="line">  fileWatcher:     filewatcher.NewWatcher(),</span><br><span class="line">  httpMux:         http.NewServeMux(),</span><br><span class="line">  monitoringMux:   http.NewServeMux(),</span><br><span class="line">  readinessProbes: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]readinessProbe),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XDSServer</code> 相关的代码在 <code>istio/pilot/pkg/xds/discovery.go</code> 中，对应为 <code>DiscoveryServer</code> ，该服务为 <code>Envoy xDS APIs </code> 的 <code>gRPC</code> 实现。 <code>DiscoveryServer</code> 关键定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> DiscoveryServer <span class="keyword">struct</span> &#123;</span><br><span class="line">  Env *model.Environment   <span class="comment">// 即上述 pilot server 中的 Environment</span></span><br><span class="line">  ConfigGenerator core.ConfigGenerator  <span class="comment">// 控制面 Istio 配置的生成器，如 VirtualService 等</span></span><br><span class="line">  Generators <span class="keyword">map</span>[<span class="keyword">string</span>]model.XdsResourceGenerator <span class="comment">// 针对不同配置类型的定制化生成器</span></span><br><span class="line">  concurrentPushLimit <span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 不同服务所有实例的集合，增量更新，key 为 service 和 namespace</span></span><br><span class="line">  <span class="comment">// EndpointShards 中是以不同的注册中心名为 key 分组保存实例</span></span><br><span class="line">  EndpointShardsByService <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">map</span>[<span class="keyword">string</span>]*EndpointShards </span><br><span class="line">  pushChannel <span class="keyword">chan</span> *model.PushRequest  <span class="comment">// 接收 push 请求的 channel</span></span><br><span class="line">  pushQueue *PushQueue     <span class="comment">// 防抖之后，真正 Push xDS 之前所用的缓冲队列</span></span><br><span class="line">  adsClients      <span class="keyword">map</span>[<span class="keyword">string</span>]*Connection  <span class="comment">// ADS 和 EDS 的 gRPC 连接</span></span><br><span class="line">  StatusReporter DistributionStatusCache  <span class="comment">// 监听 xDS ACK 和连接断开</span></span><br><span class="line">  <span class="comment">// xDS 状态更新的生成器（更新 connect, disconnect, nacks, acks）</span></span><br><span class="line">  <span class="comment">// 状态更新后向所有 connection 推送 DiscoveryResponse</span></span><br><span class="line">  InternalGen *InternalGen </span><br><span class="line">  serverReady <span class="keyword">bool</span>     <span class="comment">// 表示缓存已同步，server 可以接受请求</span></span><br><span class="line">  debounceOptions debounceOptions  <span class="comment">// 防抖设置</span></span><br><span class="line">  cache Cache <span class="comment">// xDS 资源的缓存，目前仅适用于 EDS，线程安全</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 <code>MeshConfig</code> 、 <code>KubeClient</code> 、 <code>MeshNetworks</code> 和 <code>MeshHandlers</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.initMeshConfiguration(args, s.fileWatcher)</span><br><span class="line"><span class="keyword">if</span> err := s.initKubeClient(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">&quot;error initializing kube client: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">s.initMeshNetworks(args, s.fileWatcher)</span><br><span class="line">s.initMeshHandlers()</span><br></pre></td></tr></table></figure>

<p>这几个初始化函数比较好理解， <code>initMeshConfiguration</code> 和 <code>initMeshNetworks</code> 都是通过 <code>fileWatcher</code> 对 <code>istiod</code> 从 <code>configmap</code> 中挂载的两个配置文件 <code>mesh</code> 和 <code>meshNetworks</code> 进行监听。当配置文件发生变化时重载配置并触发相应的 <code>Handlers</code> 。</p>
<p><code>filewatcher</code> 的代码在另一个管理通用工具包的项目里： <code>github.com/istio/pkg/filewatcher</code> ，感兴趣的同学可以再详细研究下，底层使用到了 <a target="_blank" rel="noopener" href="https://github.com/fsnotify/fsnotify">fsnotify</a> 这个库来推送文件变化事件。</p>
<p><code>initMeshHandlers</code> 为上述两个配置文件注册了两个 <code>Handler</code> ，当配置文件发生变化时触发全量 <code>xDS</code> 下发。</p>
</li>
<li><p>初始化 <code>Controllers</code></p>
<p>这部分比较核心，初始化了三种控制器分别处理证书、配置信息和注册信息，证书及安全相关的内容本篇先暂不讨论。主要来看 <code>initConfigController</code> 和 <code>initServiceControllers</code> 。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initControllers</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  log.Info(<span class="string">&quot;initializing controllers&quot;</span>)</span><br><span class="line">  <span class="keyword">if</span> err := s.initCertController(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error initializing certificate controller: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := s.initConfigController(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error initializing config controller: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := s.initServiceControllers(args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;error initializing service controllers: %v&quot;</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置信息大都是 <code>Istio</code> 定义的一系列 <code>CRD</code>（如 <code>VirtualService</code> 、 <code>DestinationRules</code> 等），一个控制面可以通过 <code>MCP</code> 同时接入多个 <code>Kubernetes</code> 之外的配置数据源，也可通过文件目录（主要用来调试）挂载，默认是读取 Kubernetes 中的配置数据：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initK8SConfigStore</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  configController, err := s.makeKubeConfigController(args)</span><br><span class="line">  ...</span><br><span class="line">  s.initStatusController(args, features.EnableStatus) <span class="comment">// 初始化上面提到的 StatusReporter</span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置数据包括以下类型，具体每个类型的含义 <code>Istio</code> 官网都有介绍及用例，这里不再赘述：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// PilotServiceApi contains only collections used by Pilot, including experimental Service Api.</span></span><br><span class="line">PilotServiceApi = collection.NewSchemasBuilder().</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Destinationrules).</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Envoyfilters).</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Gateways).</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Serviceentries).</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Sidecars).</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Virtualservices).</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Workloadentries).</span><br><span class="line">    MustAdd(IstioNetworkingV1Alpha3Workloadgroups).</span><br><span class="line">    MustAdd(IstioSecurityV1Beta1Authorizationpolicies).</span><br><span class="line">    MustAdd(IstioSecurityV1Beta1Peerauthentications).</span><br><span class="line">    MustAdd(IstioSecurityV1Beta1Requestauthentications).</span><br><span class="line">    MustAdd(K8SServiceApisV1Alpha1Gatewayclasses).</span><br><span class="line">    MustAdd(K8SServiceApisV1Alpha1Gateways).</span><br><span class="line">    MustAdd(K8SServiceApisV1Alpha1Httproutes).</span><br><span class="line">    MustAdd(K8SServiceApisV1Alpha1Tcproutes).</span><br><span class="line">    Build()</span><br></pre></td></tr></table></figure>

<p>详细看下 <code>initK8SConfigStore</code> 中的 <code>makeKubeConfigController</code> 方法，这里初始化了一个处理 <code>Istio CRDs</code> 的 <code>Client</code> ，实现 <code>ConfigStoreCache</code> 这个接口中增删改查等方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">makeKubeConfigController</span><span class="params">(args *PilotArgs)</span> <span class="params">(model.ConfigStoreCache, error)</span></span> &#123;</span><br><span class="line">  c, err := crdclient.New(s.kubeClient, buildLedger(args.RegistryOptions), args.Revision, args.RegistryOptions.KubeOptions)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> c, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Client</code> 定义如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  schemas collection.Schemas  <span class="comment">// Istio CRDs shemas</span></span><br><span class="line">  domainSuffix <span class="keyword">string</span></span><br><span class="line">  configLedger ledger.Ledger</span><br><span class="line">  revision <span class="keyword">string</span></span><br><span class="line">  kinds <span class="keyword">map</span>[resource.GroupVersionKind]*cacheHandler <span class="comment">// 跟踪已知类型的所有缓存 handler</span></span><br><span class="line">  queue queue.Instance</span><br><span class="line">  istioClient istioclient.Interface</span><br><span class="line">  serviceApisClient serviceapisclient.Interface</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再依次对这些类型创建 <code>Informer</code> 开启监听。回到 <code>initConfigController</code> ，创建好 <code>ConfigStore</code> 之后，再对其进一步包装：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将所有 ConfigStore 聚合并缓存</span></span><br><span class="line">aggregateConfigController, err := configaggregate.MakeCache(s.ConfigStores)</span><br><span class="line"><span class="comment">// 通过 s.configController 统一操作上面聚合的 ConfigStores</span></span><br><span class="line">s.configController = aggregateConfigController</span><br><span class="line"><span class="comment">// 将其包装为 IstioConfigStore 传入 environment，便于操作 ServiceEntry/Gateway 等资源</span></span><br><span class="line"><span class="comment">// IstioConfigStore 会在之后的 ServiceEntryStore 中用到</span></span><br><span class="line">s.environment.IstioConfigStore = model.MakeIstioStore(s.configController)</span><br></pre></td></tr></table></figure>

<p>最后将该 <code>Controller</code> 的启动函数注册到 <code>startFuncs</code> 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> s.configController.Run(stop)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>再来看 <code>initServiceControllers</code> 处理服务发现的 <code>Controller</code> 初始化:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initServiceControllers</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  serviceControllers := s.ServiceController()</span><br><span class="line">  <span class="keyword">for</span> _, r := <span class="keyword">range</span> args.RegistryOptions.Registries &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">switch</span> serviceRegistry &#123;</span><br><span class="line">    <span class="keyword">case</span> serviceregistry.Kubernetes:</span><br><span class="line">      <span class="keyword">if</span> err := s.initKubeRegistry(serviceControllers, args); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从之前初始化的 <code>environment.ServiceDiscovery</code> 中获取已注册的服务中心，如果是 <code>Kubernetes</code> 则执行 <code>initKubeRegistry</code>:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// initKubeRegistry creates all the k8s service controllers under this pilot</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initKubeRegistry</span><span class="params">(serviceControllers *aggregate.Controller, args *PilotArgs)</span> <span class="params">(err error)</span></span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  log.Infof(<span class="string">&quot;Initializing Kubernetes service registry %q&quot;</span>, args.RegistryOptions.KubeOptions.ClusterID)</span><br><span class="line">  kubeRegistry := kubecontroller.NewController(s.kubeClient, args.RegistryOptions.KubeOptions)</span><br><span class="line">  s.kubeRegistry = kubeRegistry</span><br><span class="line">  serviceControllers.AddRegistry(kubeRegistry)</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步初始化 <code>Kubernetes</code> 注册中心，方法为 <code>NewController</code> ，先看一下这个 <code>Controller</code> 的结构：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Controller <span class="keyword">struct</span> &#123;</span><br><span class="line">  client kubernetes.Interface</span><br><span class="line">  queue queue.Instance</span><br><span class="line">  serviceInformer cache.SharedIndexInformer</span><br><span class="line">  serviceLister   listerv1.ServiceLister</span><br><span class="line">  endpoints kubeEndpointsController</span><br><span class="line">  nodeInformer cache.SharedIndexInformer</span><br><span class="line">  nodeLister   listerv1.NodeLister</span><br><span class="line">  pods *PodCache</span><br><span class="line">  metrics         model.Metrics</span><br><span class="line">  networksWatcher mesh.NetworksWatcher</span><br><span class="line">  xdsUpdater      model.XDSUpdater</span><br><span class="line">  domainSuffix    <span class="keyword">string</span></span><br><span class="line">  clusterID       <span class="keyword">string</span></span><br><span class="line">  serviceHandlers  []<span class="function"><span class="keyword">func</span><span class="params">(*model.Service, model.Event)</span></span></span><br><span class="line">  instanceHandlers []<span class="function"><span class="keyword">func</span><span class="params">(*model.ServiceInstance, model.Event)</span></span></span><br><span class="line">  workloadHandlers []<span class="function"><span class="keyword">func</span><span class="params">(*model.WorkloadInstance, model.Event)</span></span></span><br><span class="line">  sync.RWMutex</span><br><span class="line">  servicesMap <span class="keyword">map</span>[host.Name]*model.Service</span><br><span class="line">  nodeSelectorsForServices <span class="keyword">map</span>[host.Name]labels.Instance</span><br><span class="line">  nodeInfoMap <span class="keyword">map</span>[<span class="keyword">string</span>]kubernetesNode</span><br><span class="line">  externalNameSvcInstanceMap <span class="keyword">map</span>[host.Name][]*model.ServiceInstance</span><br><span class="line">  workloadInstancesByIP <span class="keyword">map</span>[<span class="keyword">string</span>]*model.WorkloadInstance</span><br><span class="line">  ranger cidranger.Ranger</span><br><span class="line">  networkForRegistry <span class="keyword">string</span></span><br><span class="line">  once sync.Once</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>Controller</code> 对 <code>Services</code> 、 <code>Nodes</code> 、 <code>Pods</code> 等资源各自初始化了 <code>Informer</code> 、 Lister 以及对应的 Map，各类 Handlers 在 Informer 监听到增删改查时推送相应的事件到 queue ，再由 <code>onServiceEvent</code> 、 <code>onNodeEvent</code> 、 <code>c.pods.onEvent</code> 中更新对应的 Map 。</p>
<p>回到 <code>initServiceControllers</code> ，初始化完 Kubernetes 注册中心之后，还需要关注 Kubernetes 集群之外的服务，这些服务基本都是通过 <code>ServiceEntry</code> 注册到控制面的，所有 <code>ServiceEntry</code> 配置数据目前还都在之前初始化的 <code>configController</code> 配置中心控制器中，这里将 <code>ServiceEntry</code> 数据单独拎出来初始化一个 <code>ServicEntry</code> 注册中心，加入到 <code>serviceControllers</code> 中：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.serviceEntryStore = serviceentry.NewServiceDiscovery(</span><br><span class="line">  s.configController, s.environment.IstioConfigStore, s.XDSServer)</span><br><span class="line">serviceControllers.AddRegistry(s.serviceEntryStore)</span><br></pre></td></tr></table></figure>

<p><code>serviceEntryStore</code> 相关的逻辑会在后续 xDS 下发流程的分析中再阐述。</p>
<p>最后将 <code>serviceControllers</code> 中所有的服务注册中心的 <code>Controller</code> 的启动函数都注册到 <code>startFuncs</code> 中:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> serviceControllers.Run(stop)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Run starts all the controllers</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *Controller)</span> <span class="title">Run</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> _, r := <span class="keyword">range</span> c.GetRegistries() &#123;</span><br><span class="line">    <span class="keyword">go</span> r.Run(stop)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &lt;-stop</span><br><span class="line">  log.Info(<span class="string">&quot;Registry Aggregator terminated&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 <code>RegistryEventHandlers</code></p>
<p><code>initRegistryEventHandlers</code> 设置了三个事件处理器 <code>serviceHandler</code> 、 <code>instanceHandler</code> 和 <code>configHandler</code> 分别响应服务、实例和配置数据的更新事件。</p>
<p><code>serviceHandler</code> 如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">serviceHandler := <span class="function"><span class="keyword">func</span><span class="params">(svc *model.Service, _ model.Event)</span></span> &#123;</span><br><span class="line">  pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">    Full: <span class="literal">true</span>,</span><br><span class="line">    ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">      Kind:      gvk.ServiceEntry,</span><br><span class="line">      Name:      <span class="keyword">string</span>(svc.Hostname),</span><br><span class="line">      Namespace: svc.Attributes.Namespace,</span><br><span class="line">    &#125;: &#123;&#125;&#125;,</span><br><span class="line">    Reason: []model.TriggerReason&#123;model.ServiceUpdate&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  s.XDSServer.ConfigUpdate(pushReq)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err := s.ServiceController().AppendServiceHandler(serviceHandler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;append service handler failed: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到当服务本身发生变化时，会触发 <code>xDS</code> 的全量下发，所有与该服务相关的代理都会收到推送。</p>
<p>实例的变动也会触发 <code>xDS</code> 的全量下发，不过仅在连接 <code>Consul</code> 时生效。<code>Kubernetes</code> 和 <code>MCP</code> 这两种服务发现的场景下，更新事件的 <code>Handler</code> 是在别的地方注册的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">instanceHandler := <span class="function"><span class="keyword">func</span><span class="params">(si *model.ServiceInstance, _ model.Event)</span></span> &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> This is an incomplete code. This code path is called for consul, etc.</span></span><br><span class="line">  <span class="comment">// In all cases, this is simply an instance update and not a config update. So, we need to update</span></span><br><span class="line">  <span class="comment">// EDS in all proxies, and do a full config push for the instance that just changed (add/update only).</span></span><br><span class="line">  s.EnvoyXdsServer.ConfigUpdate(&amp;model.PushRequest&#123;</span><br><span class="line">    Full: <span class="literal">true</span>,</span><br><span class="line">    ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">      Kind:      gvk.ServiceEntry,</span><br><span class="line">      Name:      <span class="keyword">string</span>(si.Service.Hostname),</span><br><span class="line">      Namespace: si.Service.Attributes.Namespace,</span><br><span class="line">    &#125;: &#123;&#125;&#125;,</span><br><span class="line">    Reason: []model.TriggerReason&#123;model.ServiceUpdate&#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 跳过 Kubernetes 和 MCP</span></span><br><span class="line"><span class="keyword">for</span> _, registry := <span class="keyword">range</span> s.ServiceController().GetRegistries() &#123;</span><br><span class="line">  <span class="comment">// Skip kubernetes and external registries as they are handled separately</span></span><br><span class="line">  <span class="keyword">if</span> registry.Provider() == serviceregistry.Kubernetes ||</span><br><span class="line">    registry.Provider() == serviceregistry.External &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> err := registry.AppendInstanceHandler(instanceHandler); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fmt.Errorf(<span class="string">&quot;append instance handler to registry %s failed: %v&quot;</span>, registry.Provider(), err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上一步初始化了 <code>configController</code> ，它操作的对象主要是像 <code>VirtualService</code> 、 <code>DestinationRules</code> 这些 <code>Istio</code> 定义的配置，这些配置的变化也会触发 <code>xDS</code> 的全量下发，所有与该配置相关的代理都会收到推送。不过 <code>ServiceEntry</code> 和 <code>WorkloadEntry</code> 除外，这两个资源的配置下发是由 <code>ServiceEntryStore</code> 管理的，之前在初始化 <code>ServiceController</code> 时定义的 <code>s.serviceEntryStore</code> 会处理，之后的篇幅再做详细介绍。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">configHandler := <span class="function"><span class="keyword">func</span><span class="params">(_, curr model.Config, event model.Event)</span></span> &#123;</span><br><span class="line">  pushReq := &amp;model.PushRequest&#123;</span><br><span class="line">    Full: <span class="literal">true</span>,</span><br><span class="line">    ConfigsUpdated: <span class="keyword">map</span>[model.ConfigKey]<span class="keyword">struct</span>&#123;&#125;&#123;&#123;</span><br><span class="line">      Kind:      curr.GroupVersionKind,</span><br><span class="line">      Name:      curr.Name,</span><br><span class="line">      Namespace: curr.Namespace,</span><br><span class="line">    &#125;: &#123;&#125;&#125;,</span><br><span class="line">    Reason: []model.TriggerReason&#123;model.ConfigUpdate&#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  s.EnvoyXdsServer.ConfigUpdate(pushReq)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是跳过 <code>ServiceEntry</code> 和 <code>WorkloadEntry</code> 的代码：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, schema := <span class="keyword">range</span> schemas &#123;</span><br><span class="line">  <span class="comment">// This resource type was handled in external/servicediscovery.go, no need to rehandle here.</span></span><br><span class="line">  <span class="keyword">if</span> schema.Resource().GroupVersionKind() == collections.IstioNetworkingV1Alpha3Serviceentries.</span><br><span class="line">    Resource().GroupVersionKind() &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> schema.Resource().GroupVersionKind() == collections.IstioNetworkingV1Alpha3Workloadentries.</span><br><span class="line">    Resource().GroupVersionKind() &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  s.configController.RegisterEventHandler(schema.Resource().GroupVersionKind(), configHandler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化 <code>DiscoveryService</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initDiscoveryService</span><span class="params">(args *PilotArgs)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  log.Infof(<span class="string">&quot;starting discovery service&quot;</span>)</span><br><span class="line">  <span class="comment">// Implement EnvoyXdsServer grace shutdown</span></span><br><span class="line">  s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.EnvoyXdsServer.Start(stop)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  s.initGrpcServer(args.KeepaliveOptions)</span><br><span class="line">  grpcListener, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, args.ServerOptions.GRPCAddr)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">  s.GRPCListener = grpcListener</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将 <code>EnvoyXdsServer</code> 的启动添加至 <code>startFuncs</code> 中，便于后续统一启动。并初始化 <code>gRPC</code> 服务器，监听对应的端口。</p>
<p>初始化 <code>gRPC</code> 服务器，并注册 <code>xDS V2</code> 和 <code>xDS V3</code> 的 <code>ADS</code> 服务到 <code>gRPC</code> 服务器上:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">initGrpcServer</span><span class="params">(options *istiokeepalive.Options)</span></span> &#123;</span><br><span class="line">  grpcOptions := s.grpcServerOptions(options)</span><br><span class="line">  s.grpcServer = grpc.NewServer(grpcOptions...)</span><br><span class="line">  s.EnvoyXdsServer.Register(s.grpcServer)</span><br><span class="line">  reflection.Register(s.grpcServer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *DiscoveryServer)</span> <span class="title">Register</span><span class="params">(rpcs *grpc.Server)</span></span> &#123;</span><br><span class="line">  <span class="comment">// Register v2 and v3 servers</span></span><br><span class="line">  discovery.RegisterAggregatedDiscoveryServiceServer(rpcs, s)</span><br><span class="line">  discoveryv2.RegisterAggregatedDiscoveryServiceServer(rpcs, s.createV2Adapter())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>ADS</code> 的 <code>gRPC</code> 服务包含两个流式方法，一个是全量推送，一个是增量推送。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> _AggregatedDiscoveryService_serviceDesc = grpc.ServiceDesc&#123;</span><br><span class="line">  ServiceName: <span class="string">&quot;envoy.service.discovery.v3.AggregatedDiscoveryService&quot;</span>,</span><br><span class="line">  HandlerType: (*AggregatedDiscoveryServiceServer)(<span class="literal">nil</span>),</span><br><span class="line">  Methods:     []grpc.MethodDesc&#123;&#125;,</span><br><span class="line">  Streams: []grpc.StreamDesc&#123;</span><br><span class="line">    &#123;</span><br><span class="line">      StreamName:    <span class="string">&quot;StreamAggregatedResources&quot;</span>,</span><br><span class="line">      Handler:       _AggregatedDiscoveryService_StreamAggregatedResources_Handler,</span><br><span class="line">      ServerStreams: <span class="literal">true</span>,</span><br><span class="line">      ClientStreams: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      StreamName:    <span class="string">&quot;DeltaAggregatedResources&quot;</span>,</span><br><span class="line">      Handler:       _AggregatedDiscoveryService_DeltaAggregatedResources_Handler,</span><br><span class="line">      ServerStreams: <span class="literal">true</span>,</span><br><span class="line">      ClientStreams: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  Metadata: <span class="string">&quot;envoy/service/discovery/v3/ads.proto&quot;</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注册 <code>kubeClient.RunAndWait</code></p>
<p>将 <code>kubeClient.RunAndWait</code> 方法注册至 <code>startFuncs</code> 中， <code>RunAndWait</code> 启动后所有 <code>Informer</code> 将开始缓存，并等待它们同步完成。之所以在最后运行，可以保证所有的 <code>Informer</code> 都已经注册。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> s.kubeClient != <span class="literal">nil</span> &#123;</span><br><span class="line">  s.addStartFunc(<span class="function"><span class="keyword">func</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    s.kubeClient.RunAndWait(stop)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p>启动流程比较简单，核心是依次启动初始化过程中注册到 <code>startFuncs</code> 中的启动函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, fn := <span class="keyword">range</span> s.startFuncs &#123;</span><br><span class="line">  <span class="keyword">if</span> err := fn(stop); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用 <code>waitForCache</code> 等待需要监听资源的 <code>Informer</code> 缓存完毕，完成后开启 <code>HTTP</code> 服务响应 <code>readiness</code> 事件。</p>
<p>至此 <code>pilot-discovery</code> 的启动流程就结束了，有了大概了解后，可以大致归纳出整个 <code>Pilot</code> 的接口架构。</p>
<h2 id="接口设计"><a href="#接口设计" class="headerlink" title="接口设计"></a>接口设计</h2><p>在接口设计方面，<code>Pilot</code> 主要有两类接口：一种是 <code>Store</code> 类接口，定义对资源的增删改查等方法；另一种是 <code>Controller</code> 类接口，定义了 <code>RegisterEventHandler</code> 和 <code>Run</code> 方法。</p>
<p><code>Store</code> 类接口主要指 <code>ConfigStore</code> 接口，以及它衍生出的 <code>IstioConfigStore</code>，后者操作的对象为 <code>Istio</code> 定义的配置类型，如 <code>VirtualService</code>、<code>ServiceEntry</code> 等。</p>
<p>而 <code>Controller</code> 类接口指基于 <code>ConfigStore</code>  定义的 <code>ConfigStoreCache</code> 接口，这个接口在哪里用到了呢？之前讨论初始化流程的时候，分析过 <code>Pilot</code> 的 <code>Server</code> 的结构，其中用到该接口的有如下几个字段：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Server <span class="keyword">struct</span> &#123;</span><br><span class="line">  configController  model.ConfigStoreCache</span><br><span class="line">trueConfigStores      []model.ConfigStoreCache</span><br><span class="line">trueserviceEntryStore *serviceentry.ServiceEntryStore</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ServiceEntryStore <span class="keyword">struct</span> &#123;</span><br><span class="line">  store model.IstioConfigStore</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>ConfigStores</code> 是存储所有配置类数据的 <code>Controller</code> 的地方，<code>ConfigStores</code> 都是在哪里添加的呢？之前分析 <code>initConfigController</code> 方法中提到过，可以再对照代码看一下调用的地方：</p>
<p><img src="https://i.loli.net/2020/09/03/2IbDaBl91TOgNt7.png" alt="image.png"></p>
<p>都添加完毕后，会把这些 <code>ConfigStoreCache</code> 都聚合到 <code>Server.configController</code> 中统一处理。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Wrap the config controller with a cache.</span></span><br><span class="line">aggregateConfigController, err := configaggregate.MakeCache(s.ConfigStores)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">true<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">s.configController = aggregateConfigController</span><br></pre></td></tr></table></figure>

<p>而 <code>ServiceEntryStore</code> 中用到的 <code>IstioConfigStore</code> 也是在这里得到的：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">s.environment.IstioConfigStore = model.MakeIstioStore(s.configController)</span><br></pre></td></tr></table></figure>

<p>以上，当服务启动后，会逐个调用这些 <code>ConfigStoreCache</code> 中的 <code>Run</code> 方法处理资源的增删改事件。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>pilot-discovery</code> 的启动流程初看是比较复杂，但理清楚中间核心的步骤后结构也比较清晰。有了本篇的介绍，之后再走读几遍代码，相信就能很好的掌握 <code>pilot-discovery</code> 初始化的流程。</p>
<p><code>Pilot</code> 源码分析的第一部分就到这里，后续会针对重要的组件和接口做更细致的分析，如 <code>EnvoyXdsServer</code> 、<code>ServiceEntryStore</code> 等，以及梳理 <code>xDS</code> 协议的生成和下发流程，会比 <code>pilot-discovery</code> 的启动流程复杂的多，敬请期待。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a target="_blank" rel="noopener" href="https://zhaohuabing.com/post/2019-10-21-pilot-discovery-code-analysis/">Istio Pilot 代码深度解析 - 赵化冰</a></p>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E8%A7%82%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">宏观架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%A2%B3%E7%90%86"><span class="toc-number">3.</span> <span class="toc-text">启动流程梳理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text">初始化流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">启动过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text">接口设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&text=Istio Pilot 源码分析（一）"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&is_video=false&description=Istio Pilot 源码分析（一）"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=Istio Pilot 源码分析（一）&body=Check out this article: https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&title=Istio Pilot 源码分析（一）"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&name=Istio Pilot 源码分析（一）&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haidong.dev/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/&t=Istio Pilot 源码分析（一）"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2020
    zhd173
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-125225753-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'haidongdev';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
