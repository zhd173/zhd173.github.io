<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Golang 程序的诊断</title>
      <link href="//Golang%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%8A%E6%96%AD/"/>
      <url>//Golang%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%8A%E6%96%AD/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间自己写的程序出现了内存泄露，排查了很久，最终在 pprof 的帮助下提早发现了问题，还有检测并发程序中的竞争情况，也很方便。时过已久，这里再系统的总结一下。</p><h2 id="概要分析（Profiling）"><a href="#概要分析（Profiling）" class="headerlink" title="概要分析（Profiling）"></a>概要分析（Profiling）</h2><p>Go 程序可以在运行时提供 <code>pprof</code> 所需的分析数据，<code>pprof</code> 是 Go 的一款可视化工具，用以生成各种性能分析图。</p><p><code>runtime/pprof</code> 包提供了以下几种类型的分析：</p><ul><li>cpu: 统计程序花费的 CPU 时间(排除等待和IO时间)</li><li>heap: 堆检测。报告内存的分配，监视当前和历史内存的使用情况，检查内存泄露</li><li>threadcreate: 检测代码中创建线程的部分</li><li>goroutine: 报告所有 Goroutine 的堆栈跟踪</li><li>mutex: 报告锁的争用情况</li></ul><p>在 Linux 系统上，还可以使用 <a href="https://perf.wiki.kernel.org/index.php/Tutorial" target="_blank" rel="noopener">perf tools</a> 来更深入的分析 cgo/SWIG 代码和内核的性能问题。在 macOS 上可以使用 <a href="https://help.apple.com/instruments/mac/current/" target="_blank" rel="noopener">Instruments</a> 套件来分析 Go 程序。</p><h2 id="跟踪分析（Tracing）"><a href="#跟踪分析（Tracing）" class="headerlink" title="跟踪分析（Tracing）"></a>跟踪分析（Tracing）</h2><h2 id="调试（Debugging）"><a href="#调试（Debugging）" class="headerlink" title="调试（Debugging）"></a>调试（Debugging）</h2><h2 id="运行时统计（Runtime-Statistics-and-Events）"><a href="#运行时统计（Runtime-Statistics-and-Events）" class="headerlink" title="运行时统计（Runtime Statistics and Events）"></a>运行时统计（Runtime Statistics and Events）</h2><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://golang.org/doc/diagnostics.html" target="_blank" rel="noopener">Golang Diagnostics</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SSH 用法总结</title>
      <link href="//SSH%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>//SSH%20%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>SSH (Secure Shell) 是一种加密的网络传输协议。通过在网络中创建安全隧道来实现 SSH 客户端与服务端之间的连接。<br>最常见的用途就是远程登录。</p><h2 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h2><h3 id="使用密码登录"><a href="#使用密码登录" class="headerlink" title="使用密码登录"></a>使用密码登录</h3><p>以下命令是使用 user 通过 1234 端口登录 host ：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host -p <span class="number">1234</span></span><br></pre></td></tr></table></figure><p>成功后输入用户密码即可登录。第一次登录会提示无法确认主机的真实性，只知道公钥指纹，询问是否继续。如果决定接受这个远程主机的公钥，则会将该 host 的公钥保存至 <code>~/.ssh/known_hosts</code> 中，下次再连接时，系统会自动识别自动跳过警告。</p><h3 id="使用公钥登录"><a href="#使用公钥登录" class="headerlink" title="使用公钥登录"></a>使用公钥登录</h3><p>公钥登录的原理很简单。主要采用了非对称加密的方法，将公钥储存在远程主机上，登录时远程主机会发送一段随机字符串，收到字符串后用私钥加密再发送回去，远程主机用公钥进行解密，如果成功则直接登录。</p><p>本地生成好公钥后，可通过以下命令将公钥传输至远程主机：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-<span class="built_in">copy</span>-id user@host</span><br></pre></td></tr></table></figure><p>这会在远程主机的 <code>~/.ssh/authorized_keys</code> 写入发送的公钥。如果无法登录，需要检查远程主机 SSH 服务的配置文件，看是否开启了 <code>RSAAuthentication</code> <code>PubkeyAuthentication</code> 等选项。</p><h2 id="使用代理-ssh-agent"><a href="#使用代理-ssh-agent" class="headerlink" title="使用代理(ssh-agent)"></a>使用代理(ssh-agent)</h2><h3 id="简单使用代理"><a href="#简单使用代理" class="headerlink" title="简单使用代理"></a>简单使用代理</h3><p>首先要了解什么是 <code>ssh-agent</code> ，<code>ssh-agent</code> 是一个帮助程序，用来追踪用户的私钥及私钥对应的密码。之后，<code>agent</code> 可以自己使用秘钥登录到其他服务器，不需要用户再次输入密码，是一种 SSO 形式。</p><p>手动启动 <code>ssh-agent</code>:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ eval `ssh-agent`</span><br></pre></td></tr></table></figure><p>向 <code>agent</code> 中添加 SSH 私钥:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 添加私钥</span><br><span class="line">$ ssh-add ~/.ssh/key</span><br><span class="line"></span><br><span class="line"># 查看已添加的私钥</span><br><span class="line">$ ssh-add -l</span><br></pre></td></tr></table></figure><h3 id="代理转发"><a href="#代理转发" class="headerlink" title="代理转发"></a>代理转发</h3><p>这个是 <code>ssh-agent</code> 一个特别方便的功能。假如用户登录通过 <code>ssh-agent</code> 登录至远程主机，在远程主机的 SSH 客户端访问其他主机的 SSH 服务端。<br>例如我通过 SSH 登录至远程测试机，在测试机上拉取公司 Gitlab 上的项目，而 Gitlab 上仅配置了我本地主机的公钥，如果不使用 <code>ssh-agent</code> 的话，此时是拉不下来代码的。<br>如果使用了 <code>ssh-agent</code> 并开启了代理转发，测试机上的 SSH 客户端会将请求转发至本地的 <code>ssh-agent</code> 来处理，<br>从而避免了将私钥上传至远程主机或者在 Gitlab 中新增远程主机的公钥这些麻烦事了（当然也不安全，私钥应该牢牢掌握在自己手中）。</p><p>在 <code>gitlab-ci</code> 中远程部署项目时使用代理转发很方便。</p><p>如何打开代理转发：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 客户机上在配置 SSH 时需要打开</span><br><span class="line">ForwardAgent yes</span><br><span class="line"></span><br><span class="line"># 服务机上在配置 SSH 时需要打开</span><br><span class="line">AllowAgentForwarding yes</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>可以在 <code>~/.ssh/config</code> 中添加各种配置。文件没有就创建一个。</p><h3 id="配置-Host"><a href="#配置-Host" class="headerlink" title="配置 Host"></a>配置 Host</h3><p>可以在配置文件中针对不同的 Host 使用不一样的配置项：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 使用密码登录</span><br><span class="line">Host test-host-1</span><br><span class="line">    HostName 123.123.123.123</span><br><span class="line">    User user</span><br><span class="line">    Port 222</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 使用密钥登录</span><br><span class="line">Host test-host-2</span><br><span class="line">    HostName 123.123.123.111</span><br><span class="line">    User user</span><br><span class="line">    IdentityFile ~/.ssh/some-key</span><br><span class="line">    </span><br><span class="line"># 所有 Host 的共用配置</span><br><span class="line">Host *</span><br><span class="line">    AddKeyToAgent yes</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>如上配置就可以很方便的使用别名登录了：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh test-host-<span class="number">1</span></span><br><span class="line"></span><br><span class="line">$ ssh test-host-<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="常见配置项说明"><a href="#常见配置项说明" class="headerlink" title="常见配置项说明"></a>常见配置项说明</h3><ul><li>HostName：主机名，IP、域名皆可</li><li>User: 登录用户</li><li>IdentityFile: 私钥文件路径</li><li>ProxyCommand: 代理命令，例如指定本地的 sock5 端口以翻墙(nc -X 5 -x localhost:1086 %h %p)</li><li>ProxyJump: ssh tunnel 设置跳板机、堡垒机等</li><li>ForwardAgent: 是否开启代理转发</li><li>IdentitiesOnly: 只使用该选项指定的私钥，避免使用默认私钥</li><li>ServerAliveInterval: 心跳间隔</li><li>ServerAliveCountMax: 心跳重试次数</li><li>Compression: 是否启用压缩</li><li>TCPKeepAlive: TCP 保持连接不断开</li><li>UseRoaming: 是否允许漫游。即从 A 机连接至 B 机，后又用相同私钥在 C 机连接 B 机，会话保持不变</li><li>ControlMaster: 连接复用</li><li>ControlPath: 连接复用保存的地址</li><li>ControlPersist: 复用连接持续的时间</li></ul><p>其他的配置项可以参考 <a href="https://man.openbsd.org/ssh_config.5" target="_blank" rel="noopener">SSH 配置手册</a></p><h2 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h2><p>有时为了安全起见，远程服务的某些端口仅限定的主机可以访问，而用户本地仅能访问那些限定的主机。这时就可以通过端口转发，通过限定的主机将远程服务的某些端口映射到本地的特定端口，从而可以在本地直接访问远程服务的某些端口。</p><p>例如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -C -f -N -g -L <span class="number">18080</span>:<span class="number">10</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8080</span> ssh-tunnel@<span class="number">123</span>.<span class="number">1</span>.<span class="number">1</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure><p>此时访问本地的 <code>18080</code> 端口就相当于用户 <code>ssh-tunnel</code> 在 <code>123.1.1.1</code> 这台主机上访问 <code>10.0.0.1:8080</code></p><h2 id="一些建议"><a href="#一些建议" class="headerlink" title="一些建议"></a>一些建议</h2><ul><li>尽量每个单独的服务（或主机）都用不一样的密钥对，通过 ssh config 来管理</li></ul>]]></content>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>交易所项目重构总结</title>
      <link href="//%E4%BA%A4%E6%98%93%E6%89%80%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E6%80%BB%E7%BB%93/"/>
      <url>//%E4%BA%A4%E6%98%93%E6%89%80%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>18年9月，公司决定重构合作方的比特币交易所的项目。</p><p>原有项目主要使用 Java Spring Cloud 和 CPP 构建，用到的组件主要有 ActiveMQ、Redis、MariaDB、Nginx 等。在运行了一年左右出现了各种各样的问题：</p><ul><li>产品快速迭代，缺乏合理的架构合计</li><li>原有系统性能出现瓶颈，生产事故也比较多</li><li>数据库优化方面做的较差，索引不合理、慢查询较多</li><li>缺乏功能完善的运营后台管理系统</li><li>开发流程混乱，没有做好密码管理</li></ul><p>在了解了具体的业务和问题后，我们开始了该项目的重构。</p><h2 id="重构"><a href="#重构" class="headerlink" title="重构"></a>重构</h2><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>新架构延续微服务的设计，基于 gRPC 进行开发。鉴于组内人员技术栈的原因，部分子服务使用了 Python , 其余子服务使用 Golang 。新架构主要分为以下四层:</p><ul><li>统一网关层: 主要做限流、负载均衡等</li><li>对外接口层: 主要对前端提供 HTTP、Websocket 等相关接口，还有对外的 Open API</li><li>基础服务层: 包含用户管理、资产管理、币币交易、撮合引擎、行情处理、充提管理、钱包、行情推送、订单结算、内容管理、后台管理等子服务</li><li>基础组件层: RabbitMQ、MySQL、Redis 等基础组件</li></ul><p>数据库使用 MySQL，采用分库分表的策略，按照不同的业务分库，再按交易对、币种、时间分表。使用 alembic 做数据库版本管理。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li>微服务框架：采用原生 gRPC，因为同时使用 Go 和 Python 的原因，放弃了 micro 、kit 等框架</li><li>Web 框架：gin、Django</li><li>前端：Vue、TradingView</li><li>数据库：MySQL 8.0, 后续打算使用 AWS Aurora</li><li>消息中间件：主要使用 RabbitMQ，部分使用 ActiveMQ(兼容原有钱包程序)</li><li>缓存/NoSQL: AWS Redis 集群</li><li>API Gateway: Kong</li><li>Websocket: gorilla/websocket、gobwas/ws</li><li>异常采集：Sentry</li><li>日志相关：zap、loguru、logrotate</li><li>配置解析：go-ini</li><li>CI/CD: gitlab-ci、ansible、tox、supervisor</li><li>异步任务：Celery</li><li>依赖管理：Python 使用 pipenv，Go 使用 dep (后续打算使用 go modules)</li><li>其他组件：AWS SES、VPC、S3、ELB、CloudWatch、云片、极验等</li></ul><h3 id="子服务说明"><a href="#子服务说明" class="headerlink" title="子服务说明"></a>子服务说明</h3><h4 id="撮合引擎"><a href="#撮合引擎" class="headerlink" title="撮合引擎"></a>撮合引擎</h4><p>撮合引擎主要就是在内存中维护了一套 OrderBook，买卖单根据不同的顺序排列。买单列表按价格由高到低排列，卖单列表按价格由低到高排列。当收到下单消息的时候，检查 OrderBook，卖单从买单列表中匹配，买单从卖单列表中匹配。若匹配不到，就插入到 OrderBook 中排队。逻辑比较简单，但这只是简单的现货限价交易，如果是市价交易的话，撮合的时候会稍微复杂一点。主要是市价单需要处理一下价格到数量的换算问题。如果是期货的话会更复杂。</p><p>内存中撮合，OrderBook 里存的是整型的大数，因为整型的运算速度快，所以下单消息再进入撮合引擎后做了统一精度的放大。主要使用到了 bigInt 来储存（以太坊项目中大量用到了 big）。</p><p>撮合还需要注意的是高可用的问题，怎么持久化 OrderBook、怎么主从切换。</p><p>撮合最主要的是准确和效率。运算逻辑其实不难，做到准确是可以的。所以难点就在提升性能上，原有系统每秒能处理的订单数大概在 100 单左右，火币、OKey、币安等基本都是上万的。</p><h4 id="行情处理"><a href="#行情处理" class="headerlink" title="行情处理"></a>行情处理</h4><p>订单从撮合引擎成交后，撮合会发送对应的成交消息、深度更新消息到 MQ，行情处理程序通过启动多个 Worker 并发对行情进行更新。主要是更新深度、Kline、最新成交和 ticker。</p><p>Kline 需要同时更新不同时间段的。比如分钟线、小时线、日线、周线等。这个地方可以使用 goroutine 并发更新。因为不同K线之间没有依赖关系。kline 在 Redis 中的结构是哈希表，每个交易对、每种类型独占一张表。为了提升性能可以对 Kline 的内容做压缩再储存。</p><p>深度更新要稍微麻烦些，因为深度是有序的。所以在 Redis 中采用了 ZSet+Hash 的结构。Zset 保证顺序，Hash 用来存取更新数值。但后来觉得这种方式太过复杂，或许有更好的机制。比如直接从撮合引擎的 OrderBook 中截取，为什么还要单独在 Redis 中费劲维护一份呢？</p><p>最新成交比较简单，在 Redis 中维护一个固定长度的 List, 每次更新的时候 Lpush 一下，然后 LTrim 裁剪就行。</p><h4 id="行情推送"><a href="#行情推送" class="headerlink" title="行情推送"></a>行情推送</h4><p>行情在更新完毕后，都通过 RabbitMQ 的 Pub/Sub 推送到相应的 Exchange 上。由 Exchange 广播到对应的 Sub 端。行情是通过 WebSocket 推送的。刚开始用 gin 开发的 Web Server 来做 ws 服务器，使用 gorilla/websocket 这个库。给每个客户端只开一个 ws 连接，客户端通过发送消息订阅。</p><p>客户端与服务端通过 Ping 消息做心跳检测，2~3 个心跳没有回复的时候就主动断开连接。</p><p>程序刚开始跑自己没发现什么问题，后来测试环境跑了几天后发现貌似有内存泄露的问题。搞的我有点小紧张，通过 pprof 检测发现是 gorilla/websocket 这个库的 bufio 占用很高。没有释放，随着连接数的增加而增加。后来打算替换为 gobwas/ws 解决。具体这里推荐一份演讲：</p><p><a href="https://www.youtube.com/watch?v=LI1YTFMi8W4" target="_blank" rel="noopener">1m-go-websocket</a></p><h3 id="CI-CD"><a href="#CI-CD" class="headerlink" title="CI/CD"></a>CI/CD</h3><p>CI 主要是通过 gitlab-ci ，自动构建环境、lint检查、跑单元测试等。</p><p>CD 的话麻烦一点，gitlab-ci 配合 ansible roles + supervisor 来部署。除了编写 ansible roles , gitlab-ci 里需要配置好相关的 ssh-agent ，因为我们的测试环境是需要 ssh-tunnel 来登录，会麻烦一些。</p><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul><li>没有完成服务发现和配置中心相关的开发，后续服务治理、部署会带来很大不便 (可以使用 etcd3、Consul、Istio等)</li><li>下单、资产变动的分布式事务问题</li><li>行情处理的并发问题（数据竞争）</li><li>百万级 ws 连接的优化</li><li>自动上下币、对接区块链的流程未完成</li></ul>]]></content>
      
      
        <tags>
            
            <tag> golang </tag>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Golang 并发编程实践</title>
      <link href="//Golang%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/"/>
      <url>//Golang%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近的项目都使用 Golang 进行开发，因为自己是从头自学，难免踩了很多坑。目前项目接近尾声，抽空对一些重要的知识点做一些总结。</p><h2 id="Goroutine-与-Channel"><a href="#Goroutine-与-Channel" class="headerlink" title="Goroutine 与 Channel"></a>Goroutine 与 Channel</h2><p>什么是 Goroutine 呢？有人说它是轻量级的进程，或者干脆说是协程。其实都不太准确，协程仅仅是在一个进程中进行子程序的切换，而 Goroutine 是可以多线程多路复用的。简而言之，Goroutine 是一个轻量级的、与其他 Goroutine 运行在同一块内存地址中的并发执行的函数模型。它的成本仅仅比堆栈的分配高一点点，所以很廉价。Goroutine 可以在多个线程上通过 Goroutine 自己的调度器实现多路复用。</p><p>那什么是 Channel 呢？它是程序中一种类型化的通道，即在这个虚拟通道中传输的是某种预定义的数据类型。通过相应的操作符如 <code>&lt;-</code> 可以在 Goroutine 之间发送和接收数据。 Channel 在默认情况下，接收或者发送的某端没有执行的时候会阻塞程序。Channel 可以在创建时定义缓冲大小，即缓冲区已满时才会发送缓存区的所有数据。</p><p>Channel 最简单的用法就是利用其阻塞程序的特性来做 Goroutine 结束的标志。例如在 Goroutine 代码块外定义一个 Channel 接收其中的数据，当 Goroutine 代码块内部执行完毕时向 Channel 发送完成信号进而执行后续的代码。</p><p>当程序有多个 Goroutine 或者多个 Channel ，他们管理起来就容易变得混乱。这时就可以考虑使用下文讲到的知识。</p><h2 id="Select-的用法"><a href="#Select-的用法" class="headerlink" title="Select 的用法"></a>Select 的用法</h2><p>Select 用来处理一个 Goroutine 等待多个 Channel 的情况。类似于 Switch 语句，Select 的每个 case 都是一个通信操作（发送或接收），当有 case 满足条件的时候，则执行对应 case 块的代码。当没有 case 满足的时候，Select 逻辑块也会阻塞程序，当有多个 case 满足的时候，Select 会公平选择一个满足条件的 case 语句块执行。为了避免阻塞，可以使用 default 。</p><h2 id="使用-sync-包"><a href="#使用-sync-包" class="headerlink" title="使用 sync 包"></a>使用 sync 包</h2><p>Golang 并发编程离不开 sync 包，里面提供了很多有用的类型和方法。常用知识点如下：</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>普通的 map 不是并发安全的，容易出现竞争问题。sync.Map 是官方提供的一个并发安全的 Map，不需要自己额外处理锁、协调等操作。该类型提供了以下方法：</p><ul><li>Loads(): 装载键值（获取键值）</li><li>Store(): 储存键值</li><li>Delete(): 删除键值</li><li>LoadOrStore(): 如果存在则获取键值，不存在则存储</li><li>Range(): 遍历 Map</li></ul><p>我在项目中使用该类型替代了自己原本定义的一个全局 Map 类型，相比自己维护互斥锁或者读写锁等操作方便了不少，而且性能有优势（具体没有测试），据官方说明该 Map 类型显著减少了锁的争用。</p><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>互斥锁。对于加了锁的操作，其他的 Goroutine 在读取相应对象时会阻塞，知道互斥对象释放。频繁、大量的使用互斥锁会导致性能的降低，应该只在必须用的地方用。互斥锁使用不当还有可能造成死锁、活锁、饿死等情况，就比较复杂了。</p><h3 id="RWMutex"><a href="#RWMutex" class="headerlink" title="RWMutex"></a>RWMutex</h3><p>读写锁。相较互斥锁，读写锁相较互斥锁性能损耗低些，因为对于只读操作只加共享锁，是支持并发的，仅在写操作上加互斥锁，明显提升了效率。</p><h3 id="Once"><a href="#Once" class="headerlink" title="Once"></a>Once</h3><p>Once 这个对象很有用，它是一个只执行一个操作的对象。该对象仅有一个 Do() 方法，仅当 Once 实例第一次调用 Do() 方法时，Do() 才会调用传递过来的函数。</p><p>这对于要实现单例模式的代码会方便一些，定义一个 Once 对象，将要实现单例的对象的初始化方法传递给 Do()，就能保证单例的并发安全。</p><p>但使用互斥锁不也能解决这个问题吗？其实不然，互斥锁的代价太高，会导致 Goroutines 无法对该变量进行并发访问。那我把它改成读写锁呢？例如：</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mu sync.RWMutex <span class="comment">// 定义读写锁</span></span><br><span class="line"><span class="keyword">var</span> someMap <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并发安全的单例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMap</span><span class="params">(name <span class="keyword">string</span>)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">    <span class="comment">// 加读锁，并判断 someMap 是否为空</span></span><br><span class="line">    <span class="comment">// 如果不为空则获取 Map 中的值</span></span><br><span class="line">    mu.RLock()</span><br><span class="line">    <span class="keyword">if</span> someMap != <span class="literal">nil</span> &#123;</span><br><span class="line">        foo := someMap[name]</span><br><span class="line">        mu.RUnlock()</span><br><span class="line">        <span class="keyword">return</span> foo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意这里无法在 else 语句将共享锁升级为互斥锁</span></span><br><span class="line">    mu.RUnlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 someMap 为空加互斥锁，并初始化 someMap</span></span><br><span class="line">    mu.Lock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：必须要再一次检查是否为 nil</span></span><br><span class="line">    <span class="keyword">if</span> someMap == <span class="literal">nil</span> &#123; </span><br><span class="line">        CreateMap()</span><br><span class="line">    &#125;</span><br><span class="line">    foo := someMap[name]</span><br><span class="line">    mu.Unlock()</span><br><span class="line">    <span class="keyword">return</span> foo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而这种方式不觉得太复杂了吗？</p><h3 id="Pool"><a href="#Pool" class="headerlink" title="Pool"></a>Pool</h3><p>Pool 是一组用来保存或者检索的临时对象。Pub() 方法的入参是空接口，意味着可以把任何类型的对象放置在池子中以复用，减轻垃圾回收器的压力，正确的使用能很轻松的构建高效、线程安全的自由列表。</p><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><p>WaitGroup 适用于等待多个 Goroutine 完成的逻辑下使用，控制多个 Goroutine 之间的同步。每新建一个 Goroutine 就可以调用 WaitGroup.Add() 来增加需要等待的 Goroutine 数量，当每个 Goroutine 都运行完毕时各自调用 Done() ，可以在程序的外层调用 Wait() 以阻塞程序直到所有 Goroutine 都调用了 Done()。 </p><p>这样就可以在程序中使每个 WaitGroup 之间是同步的，但是 WaitGroup 之内的 Goroutine 是异步的。</p><h2 id="使用-Context"><a href="#使用-Context" class="headerlink" title="使用 Context"></a>使用 Context</h2><p>与 WaitGroup 不同，Context 实现了对串行的 Goroutine 的跟踪和控制，比如一个 Goroutine 在运行过程中派生出了其他 Goroutine，这些派生出的 Goroutine 又派生出了其他 Goroutine，这种 Goroutine 的关系链使用之前的 Channel + Select 来维护会使得程序变得异常复杂。而使用 Context 上下文来实现 Goroutine 间截止时间、取消信号或其他变量的共享和传递会变得简单。</p><p>Context 有四种方法来派生出不同的上下文：</p><ul><li>WithCancel: 传递取消信号</li><li>WithDeadline: 传递截止时间</li><li>WithTimeout: 传递超时信号</li><li>WithValue: 传递其他值</li></ul><p>例如 WithCancel 派生出的上下文，在对应 Goroutine 中调用 cancel() 会使所有同一上下文派生出的所有 Goroutine 关闭，在派生出的 Goroutine 中可以通过监听 ctx.Done() 来判断是否关闭 Goroutine。</p><p>Context 还有许多其他的用途，在 gRPC 、gin 中大量运用了 Context。Context 是并发安全的，所以可以放心的在 Goroutines 之间传递。</p><h2 id="配置-GOMAXPROCS"><a href="#配置-GOMAXPROCS" class="headerlink" title="配置 GOMAXPROCS"></a>配置 GOMAXPROCS</h2><p>GOMAXPROCS 变量限制了 Goroutine 最多能使用的线程数。默认是等于机器的 CPU 核数，一般多线程应用最佳的线程数大概为 CPU 核数 + 2 ，再多的线程就会带来额外的调度开销导致程序变慢。不过具体问题具体分析，部分程序调高这个值也能带来显著的性能提升。</p><p>参考：<a href="https://colobu.com/2017/10/11/interesting-things-about-GOMAXPROCS/" target="_blank" rel="noopener">https://colobu.com/2017/10/11/interesting-things-about-GOMAXPROCS/</a></p><h2 id="并发编程的风险与陷阱"><a href="#并发编程的风险与陷阱" class="headerlink" title="并发编程的风险与陷阱"></a>并发编程的风险与陷阱</h2><h3 id="数据竞争"><a href="#数据竞争" class="headerlink" title="数据竞争"></a>数据竞争</h3><p>解决思路：</p><ul><li>不要去写变量</li><li>避免从多个 Goroutine 访问变量<br>  这也就是官方提倡的：“不要使用共享数据来通信，而是使用通信来共享数据” ,变量仅由单个 Goroutine 来维护，其他 Goroutine 不能直接访问变量，仅可以通过使用 Channel 来发送请求给指定的 Goroutine 来查询更新变量。</li><li>加锁控制<br>  可以视具体情况选择使用互斥锁或读写锁。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> golang </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iTerm2 设置详解</title>
      <link href="//iTerm2%20%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>//iTerm2%20%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>iTerm2 是 Mac 平台下一款优秀的终端工具。虽然可以开箱即用，但默认的配置有很多还不尽人意。以下介绍一些 iTerm2 的常用设置，供大家参考（免得我自己忘了）。默认的勾选都是我的主观选择（简洁、高效），可视个人情况修改。没提到的设置都是个人觉得不太重要的，一般都没有勾选。</p><p>先放自己的<a href="https://github.com/zhd173/dotfile/blob/master/itermconfig" target="_blank" rel="noopener">配置</a> ，使用时直接将文件拷贝至</p><p><code>~/Library/Application Support/iTerm2/DynamicProfiles/</code> </p><p>即可。</p><h1 id="General"><a href="#General" class="headerlink" title="General"></a>General</h1><pre><code>[x] Copy to pasteboard on selection ：拷贝选择的内容。建议开启。[ ] Native full screen windows : 原生全屏窗口。建议关闭。</code></pre><h1 id="Appearance"><a href="#Appearance" class="headerlink" title="Appearance"></a>Appearance</h1><pre><code>[ ] Tab bar location: 标签位置。[x] Theme : 窗口主题，我选 Dark 。[ ] Show tab ... : 一系列的标签显示选项。洁癖不勾。[ ] Show per-pane title bar with split panes : 分割窗口后每个小窗口显示标题栏。洁癖不勾。[x] Auto-hide menu bar in non-native fullscreen : 非原生全屏自动隐藏菜单栏。洁癖福利，勾。[x] Exclude from Dock and Command+Tab Application Switcher : 在 Dock 和应用切换中隐藏 iTerm2[ ] Show window number ：显示窗口数字。洁癖不勾。因为我一般就用一个窗口，在窗口内分割。[ ] Show currnet job name : 显示当前工作名称。[ ] Show profile name : 显示配置文件名称。[ ] Dimming 相关 : 都不勾。勾选会有不同的模糊效果。[ ] Show border around window : 显示窗口边界。[x] Hide scrollbars : 隐藏滚动条[ ] Disable transparency for fullscreen window by default : 全屏窗口默认关闭透明。</code></pre><h1 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h1><p>快捷键这里主要设置的有两个地方：</p><pre><code>1. to switch split panes : 切换分割出的窗格快捷键。我设置为最顺手的 Command+数字 。2. Create a Dedicated Hotkey Window : 创建一个全局专用热键窗口。</code></pre><p>第二个是我最喜欢的地方。可以随时呼出 iTerm2 窗口。可以设置成半透明从上而下呼出的，也可以设置成全屏的。我设置的就是全屏，快捷键为是 Option + SPC 。详细的设置如下：</p><pre><code>[ ] Pin hotkey window : 丢失键盘焦点时保留窗口。[x] Animate showing and hiding : 打开隐藏时开启动画[x] Floating window : 浮动窗口。显示在其他全屏应用之上。</code></pre><p>设置好后会自动生成对应的 Hotkey Window Profile ，接下来讲讲怎么配置 Profile</p><h1 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h1><p>这里主要就是窗口的一些个性化设置。</p><h2 id="Colors"><a href="#Colors" class="headerlink" title="Colors"></a>Colors</h2><p>配色推荐：</p><pre><code>* Solarized Darcula* Monokai Remastered</code></pre><h2 id="Text"><a href="#Text" class="headerlink" title="Text"></a>Text</h2><pre><code>[x] Blinking cursor : 闪烁光标，切割多屏的时候容易找不到光标。[ ] Draw bold text in bright colors : 开启有时会导致颜色不显示。</code></pre><p>字体推荐：</p><pre><code>* Souce Code Pro Nerd Font</code></pre><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><pre><code>* Transparency : 透明度* Blur : 模糊* Style : Fullscreen 全屏样式，有喜欢下拉半屏或者上弹半屏的可以选其他。* Screen : Screen2 在哪个屏幕打开。我一般喜欢在外接显示器打开。* Space : All Spaces</code></pre><h2 id="Keys-1"><a href="#Keys-1" class="headerlink" title="Keys"></a>Keys</h2><pre><code>* 有使用 Emacs 的童鞋可以将 Left(Right) Option Key 调整为 Esc+ 以启用 Meta 键* HotKey Window : 勾选，默认是勾选的。</code></pre><p>以上就是我配置 iTerm2 常用到的配置。在打开 iTerm2 之后，关掉默认打开的窗口（因为那是原生窗口，我常用的是浮动窗口）。接着就可以用之前定义的全局快捷键（ Option + SPC ）呼出 iTerm2 浮动窗口了。<br>在调好了透明度、模糊、背景图之后，全局呼出的时候很酷炫。不过我不是很喜欢太花里胡哨的，简洁方便至上。</p><p>常用的快捷键如下：</p><pre><code>* Command + D ：垂直分割* Command + Shift + D : 水平分割* Command + 数字键 ：分割窗格间切换* Command + w : 关闭当前窗口* Command + q : 退出 iTerm2* Command + l : 清屏* Ctrl + w : 删除一个单词* Ctrl + a : 光标置于行首* Ctrl + e : 光标置于行末</code></pre>]]></content>
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>如何优雅的管理本地多版本的 Python</title>
      <link href="//%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%A4%9A%E7%89%88%E6%9C%AC%E7%9A%84%20Python/"/>
      <url>//%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AE%A1%E7%90%86%E6%9C%AC%E5%9C%B0%E5%A4%9A%E7%89%88%E6%9C%AC%E7%9A%84%20Python/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在本地尝试将某个项目迁移至 Python3.7.0 ，但是本地还有其他项目依赖 3.6.5 ，加上系统自带的 Python2，本地已经有3个不同版本的Python了。第一次我是通过官方的<code>.dmg</code>包安装 Python3.7.0 的，但之后发现它把 Python 安装到了：<code>/Library/Frameworks/Python.framework/Versions</code> ，但是我本地之前安装的 3.6.5 和 2.7.15 都是通过 <code>Homebrew</code> 安装的，卸载、更新、设置软连接都很方便。<code>Homebrew</code>安装的默认在 <code>/usr/local/Cellar/python</code> 中。</p><p>这样当你切换本地 python 的版本时就很麻烦，要重设一些软连接，python\python3\pydoc\pip3… 当然我知道项目内部可以用虚拟环境来管理 Python 版本。但是不可避免一些常用的软件的 Python 依赖出现问题。比如 IPython\legit\Emacs 等等，当我手动升级了版本后，这些包（软件）常常会报错，告诉你 python3.6.5 或者 python3.7.0 找不到了。每次修复软连接就很烦。</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我的解决方案就是：统一使用 <code>Homebrew</code> 来管理 Python 版本。只要本地安装过旧版本，没有执行<code>brew clean</code>等命令（即 <code>/usr/local/Cellar/python/</code> 路径下有多个版本的文件夹，如 3.6.5 、3.7.0 等），就可以使用命令<code>brew switch python [versions]</code> 来切换 Python 的版本了。如：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ brew switch --<span class="built_in">help</span></span><br><span class="line">brew switch formula version:</span><br><span class="line">    Symlink all of the specific version of formula's install to Homebrew prefix.</span><br><span class="line"></span><br><span class="line">$ brew switch python <span class="number">3</span>.<span class="number">7</span>.<span class="number">0</span>                                                                                <span class="number">763</span>ms</span><br><span class="line">Cleaning /usr/local/Cellar/python/<span class="number">3</span>.<span class="number">7</span>.<span class="number">0</span></span><br><span class="line">Cleaning /usr/local/Cellar/python/<span class="number">3</span>.<span class="number">6</span>.<span class="number">5</span>_1</span><br><span class="line"><span class="number">25</span> links created <span class="keyword">for</span> /usr/local/Cellar/python/<span class="number">3</span>.<span class="number">7</span>.<span class="number">0</span></span><br></pre></td></tr></table></figure><h1 id="如何安装旧版本的Python"><a href="#如何安装旧版本的Python" class="headerlink" title="如何安装旧版本的Python"></a>如何安装旧版本的Python</h1><p>当然有的小伙伴会说，使用<code>switch</code>命令会报错。因为<code>/usr/local/Cellar/python/</code>文件夹下没有其他版本的 Python ，<code>Homebrew</code>自然也就找不到了。所以该怎么使用<code>Homebrew</code>安装旧版本的 Python 呢？</p><p>首先要先知道 <code>Homebrew</code> 的工作方式。当你执行 <code>brew install python</code>时，实际是执行<code>$ brew install https://github.com/Homebrew/homebrew-core/blob/master/Formula/python.rb</code> 。所以我们可以通过替换其 URL 地址来安装旧版本。 <code>Homebrew</code>既然是使用<code>Git</code>来管理更新包的，那就可以查看<code>python.rb</code>的历史：</p><p><a href="https://github.com/Homebrew/homebrew-core/commits/master/Formula/python.rb" target="_blank" rel="noopener">python.rb</a></p><p>如果提示无法查看可以<code>clone</code>到本地使用以下命令查看：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log master -- Formula/python.rb</span><br></pre></td></tr></table></figure><p>例如 Python3.6.5 的安装方法为:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew unlink python</span><br><span class="line">$ brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/e128fa1bce3377de32cbf11bd8e46f7334dfd7a6/Formula/python.rb</span><br></pre></td></tr></table></figure><p>需要先运行 <code>brew unlink python</code> 来删除软连接。否则<code>Homebrew</code>会因为已经安装了 3.7.0 导致安装失败。</p><p>安装成功之后就可以优雅的使用<code>brew switch python 3.7.0</code> 或者 <code>brew switch python 3.6.5</code> 愉快的切换版本了。</p><h1 id="使用-Pyenv-管理本地多版本的-Python"><a href="#使用-Pyenv-管理本地多版本的-Python" class="headerlink" title="使用 Pyenv 管理本地多版本的 Python"></a>使用 Pyenv 管理本地多版本的 Python</h1><p>使用 Homebrew 管理 Python 版本也有很多局限性。例如切换 Python 版本后会导致原来一些依赖 Python 特定版本的应用无法使用。比如 brew 安装的 pipenv 、IPython 等。替代方案是使用 Pyenv 维护本地不同的版本。</p><h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>我认为的最佳实践是在本地使用<code>Homebrew</code>安装 <code>python@2</code> 和 <code>python</code>（如果需要 Python2 的话）。<code>python</code>即为<code>Homebrew</code> Python3 的最新版本。当需要其他特定版本 Python3 的时候，使用特性版本对应的 URL 安装。之后使用 <code>brew switch</code>命令随时切换（同样适用于其他 <code>Homebrew</code> 管理的软件）。</p><p>以安装 Python2.7.15、Python3.6.5、Python3.7.0 举个例子:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 删除之前安装的所有 Python 和相关的软连接</span><br><span class="line">$ brew unlink python@<span class="number">2</span></span><br><span class="line">$ brew unlink python</span><br><span class="line">$ rm -rf /usr/local/Cellar/python/</span><br><span class="line">$ sudo rm -rf /Library/Frameworks/Python.framework/Versions/x.x</span><br><span class="line">$ sudo rm -rf "/Applications/Python x.x"</span><br><span class="line">$ <span class="built_in">cd</span> /usr/local/bin/</span><br><span class="line">$ ls -l /usr/local/bin | grep '../Library/Frameworks/Python.framework/Versions/x.x' | awk '&#123;<span class="built_in">print</span> $<span class="number">9</span>&#125;' | tr -d @ | xargs rm</span><br><span class="line"></span><br><span class="line"># 安装 Python2.<span class="number">7</span>.<span class="number">15</span></span><br><span class="line">$ brew reinstall python@<span class="number">2</span></span><br><span class="line"></span><br><span class="line"># 安装最新版本的 Python3</span><br><span class="line">$ brew reinstall python</span><br><span class="line"></span><br><span class="line"># 安装 Python3.<span class="number">6</span>.<span class="number">5</span></span><br><span class="line">$ brew unlink python</span><br><span class="line">$ brew install https://raw.githubusercontent.com/Homebrew/homebrew-core/e128fa1bce3377de32cbf11bd8e46f7334dfd7a6/Formula/python.rb</span><br><span class="line"></span><br><span class="line"># 切换 Python3 的版本为 <span class="number">3</span>.<span class="number">7</span>.<span class="number">0</span></span><br><span class="line">$ brew switch python <span class="number">3</span>.<span class="number">7</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"># 切换 Python3 的版本为 <span class="number">3</span>.<span class="number">6</span>.<span class="number">5</span></span><br><span class="line">$ brew switch python <span class="number">3</span>.<span class="number">6</span>.<span class="number">5</span></span><br></pre></td></tr></table></figure><p>相关软连接对应关系如下(Python3的版本为3.7.0为例)：</p><ul><li>python –&gt; python2.7.15</li><li>pip –&gt; pip for python2.7.15</li><li>python3 –&gt; python3.7.0</li><li>pip3 –&gt; pip for python3.7.0</li></ul><p>如果使用 Pyenv 安装了其他小版本的 Python ,可以考虑将对应的 Python 解释器连接至 <code>/usr/local/bin</code> 中，便于 <code>pipenv</code> 创建虚拟环境时通过 <code>--python</code> 来指定版本。不过用 Pyenv 来管理虚拟环境也行。</p><p><em>PS：最终我选择了 Golang , 终于没有这些恼人的版本问题了😂。</em></p>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>那些我喜欢看的动画片</title>
      <link href="//%E9%82%A3%E4%BA%9B%E6%88%91%E5%96%9C%E6%AC%A2%E7%9C%8B%E7%9A%84%E5%8A%A8%E7%94%BB%E7%89%87/"/>
      <url>//%E9%82%A3%E4%BA%9B%E6%88%91%E5%96%9C%E6%AC%A2%E7%9C%8B%E7%9A%84%E5%8A%A8%E7%94%BB%E7%89%87/</url>
      <content type="html"><![CDATA[<p>无意中听到《灌篮高手》的歌 <code>君が好きだと叫びたい</code> ，一时感慨万千。大概是我小升初的假期，每天窝在表姐家【看】表哥表姐玩电脑。那时在一个四五线小县城，有一台戴尔笔记本电脑还是很 skr 的。表哥喜欢玩暗黑破坏神，表姐就喜欢看《灌篮高手》。那时的我啊，每天在家里就等着看点播台的《火影忍者》，一集一集的等别人点了才能看。但表姐那个是下载好的，别提有多吸引我了。今天整理一下这些我喜欢看的动画片，有空再看一遍！</p><h1 id="《宝莲灯》"><a href="#《宝莲灯》" class="headerlink" title="《宝莲灯》"></a>《宝莲灯》</h1><p>这真的是我最喜欢的动画片了。尤其那小猴特别可爱，包括去二郎神宝库偷宝莲灯的那段，以及后来去找三圣母的路上，小猴笑的捶地的时候……小时候每次看到小猴就笑个不停（没错这个碟我也就看了十几遍吧）。当然还有音乐，那时候不懂，只觉得《宝莲灯》配的三首歌都特别好听。到后来大一点，才知道这些歌有多大牌。李玟的《爱你的三百六十五天》，张信哲的《爱就一个字》、刘欢的《天地在我心》。前两首到现在我在KTV的时候还点来唱两句。配音也是很出色的，映象最深的当然就是孙悟空了，那是陈佩斯配的，记得有一句 “我老孙不把你打的满脸桃花开，你就不知道花儿为什么这样红” 是这儿来的吧。我就想以后我有孩子的时候，肯定都会给他看这些。</p><h1 id="《哪吒闹海》"><a href="#《哪吒闹海》" class="headerlink" title="《哪吒闹海》"></a>《哪吒闹海》</h1><p>这部动画片塑造的哪吒，在我心目中是最有美感的。讲真那时候的美术，真的不比现在的日漫差，我甚至觉得那时候动画片的美术更有艺术气息。记得2014年的5月30日，Google 的首页曾改为这部动画电影中哪吒的造型。混天绫环绕组成六个字母，还挺好看的。</p><p><img src="https://cdn2.ettoday.net/images/623/d623590.jpg" alt="avatar"></p><p>映像比较深的是哪吒在海边洗澡，骑着梅花鹿，鲜红的混天绫环绕在身边，海水拍岸。还有一个镜头，就是哪吒自刎的那段， 小时候真的是看哭了。真的希望现在也能拍出这么优秀的动画电影。不需要多高端的技术，多逼真的 3D 建模，我们有那么多有意思的神话故事，也有自己的国画风格，音乐创作也不差，怎么就出不了呢。</p><h1 id="《四驱兄弟》"><a href="#《四驱兄弟》" class="headerlink" title="《四驱兄弟》"></a>《四驱兄弟》</h1><p>还记得校门口的晨光玩具店吗，还记得自己动手绕的奥迪双钻马达吗?这都源自这部动画片，小烈和小豪，飓风音速旋风冲锋新三角箭眼镜蛇巨无霸，还有那首主题歌：“抬头望望天，月亮在笑” …… 这部动画片在当时的小学生间掀起了一股穷也玩车，富也玩车的潮流。小学门口的玩具店有个不大的跑道，孩子们都围在旁边，看看谁的车子跑的最快，谁又换了牛逼的马达，谁装了铝合金的前后导轮。我那时也有一个工具箱，买的一个四驱车好像叫雪豹，自己改装了好多好多东西，放学的时候就拿到玩具店去比赛。现在想想什么是童年，这才是童年。</p><h1 id="《游戏王》"><a href="#《游戏王》" class="headerlink" title="《游戏王》"></a>《游戏王》</h1><p>emmmm，还是那个玩具店，车玩了一段时间之后就开始玩卡。说的就是游戏王。前段时间还下载了一个游戏王的手游刷了刷天梯，但毕竟是长大了，有些东西长大了就体会不到了。玩了没多久就删掉，可能好看的不是动画片，好玩的不是游戏卡，只是单纯的怀念那时单纯的我们吧。谁谁谁又摸出了青眼白龙，还是那种带闪的，谁谁谁集齐了暗黑大魔神。但我最喜欢的是天空龙，感觉特别酷。好像很多日漫都有这样的设定，精英主角身边总有一个逗比，就像游戏和龙之介，我比较喜欢龙之介，特别有义气的兄弟。</p><h1 id="《宠物小精灵》"><a href="#《宠物小精灵》" class="headerlink" title="《宠物小精灵》"></a>《宠物小精灵》</h1><p>这个要说的太多。因为不仅是这部动画片，还有一个同名的游戏，现在叫《精灵宝可梦》。最熟的就是皮卡丘了吧。其实小精灵里我最喜欢伊布。动画片里的话，映像最深的是那位男装小姑娘，拥有常磐森林的治愈力量，能够与精灵们交流的小黄（漫画好像叫小洛），小达拉是她第一个小精灵，后面还有嘟嘟，皮卡丘（小智被打伤之后找到小黄）。当然还有最可爱的反派火箭队三人组了（喵喵：？？）。今年 Switch 上会发布跟这部动画片第一部剧情一样的游戏，真的是非常期待，我肯定买伊布版，刷爆全国图鉴。</p><h1 id="《光能使者》"><a href="#《光能使者》" class="headerlink" title="《光能使者》"></a>《光能使者》</h1><p>小男孩小时候爱看这个吧，我看了之后每天都在自己本儿上画六芒星魔法阵。但是具体的剧情现在记不清了，就记得 “如意神剑” ，还有大地的是光能使者，是地和火属性，还有个小帅哥是水属性，小胖子的是风属性。其他都记不起来。</p><h1 id="《数码宝贝》"><a href="#《数码宝贝》" class="headerlink" title="《数码宝贝》"></a>《数码宝贝》</h1><p>这个映像最深的就是主题曲 <code>butterfly</code> 了。当时我上小学，班上一大半的女同学课间都在学这首歌，每次上课前等老师的时候，班长一般会提大家唱歌。那段时间每天就唱 <code>butterfly</code> ，小孩儿哪懂什么日语，就标注拼音强行学，这么说来着还是我学的第一首日文歌。我最喜欢的数码宝贝是天使兽。虽然我也很纳闷我怎么喜欢的都是这种治愈系的角色，比如小黄，比如天使兽。这部动漫虽然也有同名游戏，当时玩过PSP上的一款，怎么都提不起兴趣，感觉不是很好玩。</p><h1 id="《犬夜叉》"><a href="#《犬夜叉》" class="headerlink" title="《犬夜叉》"></a>《犬夜叉》</h1><p>犬夜叉么，当然要说桔梗和杀生丸了。日本的这些神魔志怪其实还挺有意思的，出的游戏也好玩。桔梗，其实我小时候理解的就是桔子的梗，就是桔子里面白色的那个东西。后来才知道桔梗原来是一种特别漂亮的花。这部动漫的剧情特别曲折感人，主要就在桔梗和犬夜叉的爱情故事上。桔梗生来就是为了守护四魂之玉，这过程中认识了犬夜叉并发展出一段恋情。但是后来有个鬼蜘蛛的强盗也喜欢上了桔梗，在知道桔梗和犬夜叉的恋情后因爱生恨，把自己的身体奉献给了妖怪最终变成了奈落，奈落从中挑拨离间使桔梗和犬夜叉反目成仇。犬夜叉去夺四魂之玉的时候被桔梗封印。桔梗为了让四魂之玉消失而火化。后来桔梗复活，犬夜叉也从封印中醒来，最后走了很曲折的路才冰释前嫌，但最终和奈落的大战中消失了。杀生丸，一个字就是帅。跟佐助似的，不过不一样的是他是从冷酷变温柔。从铃被群狼咬死之后，第一次用天生牙救活铃开始，杀生丸就变得可爱多了。</p><h1 id="《火影忍者》"><a href="#《火影忍者》" class="headerlink" title="《火影忍者》"></a>《火影忍者》</h1><p>火影算是追的最久最辛苦的一部了。以至于我再也没有勇气追其他的民工漫，像海贼什么的。小学看到忍者考试，初中的时候上网吧看疾风传，动画没出就一遍一遍的刷漫画。中间有一年多没看，到高中又重头看了一遍。大学说要完结的时候才真正看完。回首这一路程还挺艰辛的，发个贴那些年我们一起追过的疾风传肯定好多人回吧。火影里塑造的角色都很经典，像君麻吕、自来也、宇智波鼬，都是我很喜欢的角色。火影里的感情太复杂了，有佐助和鼬的手足之情，有宇智波斑和千手、佐助和鸣人这样互为挚友、互为对手的情感，有守护家族、村子、国家的情感，有师徒、男女、父子之情……</p><p>这里要说说鹿丸了，就是这样的一个不起眼的角色总让人着迷：</p><blockquote><p>我本来想过着随便当个忍者，随便赚点钱。然后和不美又不丑的女人结婚，生两个小孩，第一个是女孩，第二个是男孩。等长女儿结婚，儿子也能够独当一面的时候，就从忍者的工作退休。之后，每天过着下将棋或围棋的悠闲隐居生活。然后比自己的老婆还要早老死，我就是想过这种生活。</p></blockquote><p>我自己就喜欢这种淡然的生活，所以当看到鹿丸讲这句话的时候，我就说，这人我粉了。</p><h1 id="《灌篮高手》"><a href="#《灌篮高手》" class="headerlink" title="《灌篮高手》"></a>《灌篮高手》</h1><p>樱木花道、流川枫和赤木晴子。真的像鸣人、佐助和小樱。剧情就不说了，我映像最深的是教练那胖乎乎的脸蛋，花道老是用手去搓，那声音就像是擦玻璃似的特别逗。两位都是天才，但也付诸了相当多的努力，灌篮和火影一样，就是热血和拼搏，就是燃。给我最大的感触就是团队吧，团队合作很重要。</p><h1 id="《头文字D》"><a href="#《头文字D》" class="headerlink" title="《头文字D》"></a>《头文字D》</h1><p>这个很多人喜欢，但是我没有全部跟完，看的是剧场版和电影。还有前段时间重置的3集。秋名山的AE86，爸爸的老奔驰。</p><h1 id="《七龙珠》"><a href="#《七龙珠》" class="headerlink" title="《七龙珠》"></a>《七龙珠》</h1><p>这个小时候刚开始看的是漫画，每天放学去桥头的书店看巴掌大的黑白版漫画，废寝忘食。从第一次跟布尔玛踏出山林寻找龙珠，到天下第一武道会，到打倒比克大魔王，这段感觉都特别精彩。到后来动辄全宇宙、平行宇宙的，虽然有点扯，但是头发颜色一直变变变还是蛮酷的。上个月才整整看完龙珠超，看到最后悟空的自在极意功，简直帅呆酷毙无法比喻，看到这之后的故事线就没看了（工作确实忙啊！）。论造型，最喜欢超一，论颜色，最喜欢超蓝+界王拳，就是蓝色外面裹一层红色。最喜欢的角色？当然是皮拉夫和饺子了，这是我心里永远的CP。</p><h1 id="《百变小樱魔术卡》"><a href="#《百变小樱魔术卡》" class="headerlink" title="《百变小樱魔术卡》"></a>《百变小樱魔术卡》</h1><p>是的没错，这个我也爱看。我还喜欢月。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>还有一些好看的动画片，限于篇幅，不展开回忆了。也是很好看的。</p><ul><li>《葫芦娃》</li><li>《封神榜传奇》</li><li>《铁臂阿童木》</li><li>《西游记》</li><li>《铁胆火车侠》</li><li>《足球小子》</li><li>《中华小当家》</li></ul>]]></content>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>H5 页面调起微信支付总结</title>
      <link href="//H5%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%B5%B7%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%80%BB%E7%BB%93/"/>
      <url>//H5%20%E9%A1%B5%E9%9D%A2%E8%B0%83%E8%B5%B7%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>最近的工作是一个微信公众号的开发项目。有个小需求是在公众号内的H5页面调起微信支付，这里简单概括一下开发流程。详细的步骤可以直接查看<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1" target="_blank" rel="noopener">微信支付官方开发文档</a>。</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><p>在开发之前需要准备一个拥有支付权限的微信公众号。下文以普通的商户服务号为例。服务号开通微信支付权限之后，会发邮件告知以下信息：</p><pre><code>* 微信支付商户号（MCH_ID）* 微信公众账号ID（APP_ID）* 微信支付API秘钥（MCK_KEY）* 微信公众账号Secret（APP_SECRET）</code></pre><p>保存好这些信息，会在之后的接口请求中使用。</p><h1 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h1><p>公众号内支付主要有以下业务流程：</p><h2 id="获取微信用户openid"><a href="#获取微信用户openid" class="headerlink" title="获取微信用户openid"></a>获取微信用户<code>openid</code></h2><p>使用 APP_ID 和 APP_SECRET 获取微信用户<code>openid</code>，该 ID 仅在当前公众号有效。跟 APP_ID 绑定。</p><h2 id="前端向后端发起支付请求"><a href="#前端向后端发起支付请求" class="headerlink" title="前端向后端发起支付请求"></a>前端向后端发起支付请求</h2><p>例如用户点击了支付按钮，前端参数请求 <code>GET wx/config</code> (自拟)接口以获取需要在客户端调起 JSAPI 的参数。</p><h2 id="后端收到支付请求后访问微信统一下单接口"><a href="#后端收到支付请求后访问微信统一下单接口" class="headerlink" title="后端收到支付请求后访问微信统一下单接口"></a>后端收到支付请求后访问微信统一下单接口</h2><p><a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_1" target="_blank" rel="noopener">统一下单支付接口</a></p><p>参考上面的文档传入一下参数：</p><pre><code>* appid 公众账号ID* mac_id 商户号* nonce_str 随机字符串，用来给签名加盐* sign 签名* body 商品描述，用以支付成功后微信给用户返回支付结果* out_trade_no 随机字符串，作为微信订单流水号* total_fee 支付总价，注意单位为分* spbill_create_ip 用户终端IP* notify_url 微信回调地址，用以接收微信支付结果* trade_type 交易类型，公众号内H5页面为 JSAPI* openid 用户唯一标示</code></pre><p>一般情况下这里容易出现以下错误：</p><pre><code>* 签名错误，一定要注意参数名的大小写，务必与文档一致* openid 与 appid \ mch_id 不符* total_fee 用了浮点数。该参数单位为分，不可使用小数</code></pre><p>请求成功后，微信会返回成功信息，我们主要用到里面的<code>prepay\_id</code>字段。</p><p>这里我们可以在业务数据库中插入一条交易信息，以管理这些微信支付的订单。具体的表字段可以看自己的需求设计。</p><h2 id="后端准备前端调用-JSAPI-所需的参数"><a href="#后端准备前端调用-JSAPI-所需的参数" class="headerlink" title="后端准备前端调用 JSAPI 所需的参数"></a>后端准备前端调用 JSAPI 所需的参数</h2><p>前端调起微信支付 JSAPI 所需的参数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">raw = dict(</span><br><span class="line">    appId=self.app_id,</span><br><span class="line">    timeStamp=timestamp,</span><br><span class="line">    nonceStr=nonce_str,</span><br><span class="line">    package=package,</span><br><span class="line">    signType=<span class="string">"MD5"</span>)</span><br><span class="line"><span class="comment"># 签名</span></span><br><span class="line">sign = self.sign(raw)</span><br></pre></td></tr></table></figure><p>签名时注意大小写。</p><h2 id="前端调起微信支付"><a href="#前端调起微信支付" class="headerlink" title="前端调起微信支付"></a>前端调起微信支付</h2><p>前端使用上一步传入的参数使用 JSAPI 调起微信支付，直接请求微信支付接口，微信会返回给前端以下情况：</p><pre><code>* get_brand_wcpay_request:ok 支付成功* get_brand_wcpay_request:cancel 支付取消* get_brand_wcpay_request:fail 支付失败* 调用支付JSAPI缺少参数：total_fee</code></pre><p>前端需要针对不同的返回做不同的处理，尽量不要直接将错误反馈给用户。</p><h2 id="异步-微信返回支付结果给后端"><a href="#异步-微信返回支付结果给后端" class="headerlink" title="[异步] 微信返回支付结果给后端"></a>[异步] 微信返回支付结果给后端</h2><p>通过在统一下单接口中的<code>notify_url</code>回调地址，微信会发送支付的结果给这个接口。后端对应的接口就需要根据微信返回的结果处理自身的业务数据，比如我们是生成某种会员卡，然后完善数据库之前下单时生成的交易订单信息。</p><p>处理完这些后，需要给微信反馈你处理的结果。具体格式参见<a href="https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=9_7&amp;index=8" target="_blank" rel="noopener">微信支付结果通知文档</a></p><p>这里如果没有正确发送给微信相应的通知，微信会重复发送请求，导致业务数据的混乱。</p><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>有一个非常容易出错的地方一定要注意：</p><pre><code>* 签名的算法需要再三验证准确性* 签名所需的参数名一定要和微信所需要的参数名大小写一致，否则会导致签名验证失败* 支付金额参数的单位是分* 处理回调时需要考虑微信重复发送支付结果的情况（主要是业务数据的去重）</code></pre>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>说说 Python3.7</title>
      <link href="//%E8%AF%B4%E8%AF%B4Python3-7/"/>
      <url>//%E8%AF%B4%E8%AF%B4Python3-7/</url>
      <content type="html"><![CDATA[<p>昨天 Python 3.7 正式发布，新功能都很棒，简单研究一下。这些新的特性主要包括：</p><ul><li>内置断点 <code>breakpoint()</code> </li><li>数据类 <code>dataclass</code></li><li>定制访问模块属性</li><li>改进了对类型提示的支持</li><li>更高精度的定时功能</li></ul><h1 id="更便捷的断点调试"><a href="#更便捷的断点调试" class="headerlink" title="更便捷的断点调试"></a>更便捷的断点调试</h1><p>之前调试一般有四种方法：</p><ul><li>使用 <code>print()</code> 函数来打印变量</li><li>导入 <code>pdb</code> 模块，使用 <code>set_trace()</code> 方法来打断点</li><li>使用 <code>IPython</code> 调试</li><li>使用其他 IDE 进行调试</li></ul><p>在 Python 3.7 中，上面第二种调试方法有了更便捷的实现，就是使用新增的 <code>breakpoint()</code> 方法。它会隐式调用 <code>pdb.set_trace()</code>，运行程序时会在断点处暂停，并进入 <code>pdb</code> 调试环境。接着就可以用 <code>pdb</code> 的一些方法来调试了，比如 c 、 p 等。进一步了解可以参考 <a href="https://realpython.com/python-debugging-pdb" target="_blank" rel="noopener">这里</a> 。</p><p>在不需要断点调试的时候，指定环境变量 <code>PYTHONBREAKPOINT</code> 的值为 0 ，执行脚本过程中就会自动跳过 <code>breakpoint()</code>。就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PYTHONBREAKPOINT=<span class="number">0</span> python3<span class="number">.7</span> test.py</span><br></pre></td></tr></table></figure><p>该环境变量还可以指定使用 IPython 来调试，比如这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PYTHONBREAKPOINT=IPython.embed python3<span class="number">.7</span> test.py</span><br></pre></td></tr></table></figure><p>更深度的话我们可以定制 <code>breakpoint()</code> 函数，可以自定义一个函数让 <code>breakpoint()</code> 调用，比如保存断点处的变量，自定义模块<code>bp_utils</code> 如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_locals</span><span class="params">()</span>:</span></span><br><span class="line">    caller = sys._getframe(<span class="number">1</span>)  <span class="comment"># Caller is 1 frame up.</span></span><br><span class="line">    pprint(caller.f_locals)</span><br></pre></td></tr></table></figure><p>接着可以这样调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ PYTHONBREAKPOINT=bp_utils.print_locals python3<span class="number">.7</span> test.py</span><br></pre></td></tr></table></figure><h1 id="Data-Classes"><a href="#Data-Classes" class="headerlink" title="Data Classes"></a>Data Classes</h1><p>在平时工作中，如果一个类的初始化参数特别多，写 <code>__init__</code> 方法会很累。另外，如果不定义 <code>__repr__</code> 方法，打印类对象的方式很不友好，不能一眼看出这个类是干什么的。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(SomeClass)</span><br><span class="line">&lt;test.SomeClass at <span class="number">0x12ba6c310</span>&gt;</span><br></pre></td></tr></table></figure><p>所以我们可以定义 <code>__repr__</code> 方法来使打印的结果更友好，比如打印出这个类的前几个参数。但当我们需要定义的类特别多的时候，每个类都需要手写一遍 <code>__repr__</code>，太麻烦了。再有，当我们需要判断两个对象是否相等，或者对对象去重的时候，目前的解决方案是定义 <code>__eq__</code> 、 <code>__gt__</code> 、 <code>__lt__</code> 、 <code>__hash__</code> 等方法。当然也需要手写。</p><p>但使用 Python 3.7 中新添加的 <code>dataclasses</code> 模块就不一样了，像上述的 <code>__init__</code> , <code>__repr__</code> , <code>__eq__</code> , <code>__hash__</code> 等方法都会 <strong>自动</strong> 添加，是不是很方便？例如可以这样写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass, field</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass(order=True, hash=True)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span>:</span></span><br><span class="line">    name: str</span><br><span class="line">    population: int</span><br><span class="line">    area: float = field(repr=<span class="keyword">False</span>, compare=<span class="keyword">False</span>)</span><br><span class="line">    coastline: float = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">beach_per_person</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""Meters of coastline per person"""</span></span><br><span class="line">        <span class="keyword">return</span> (self.coastline * <span class="number">1000</span>) / self.population</span><br></pre></td></tr></table></figure><p>这样写之后，再对类实例做打印、比较、去重时就方便多了。</p><h2 id="以下部分内容我还没搞懂，先占坑。"><a href="#以下部分内容我还没搞懂，先占坑。" class="headerlink" title="以下部分内容我还没搞懂，先占坑。"></a>以下部分内容我还没搞懂，先占坑。</h2><h1 id="Customization-of-Module-Attributes"><a href="#Customization-of-Module-Attributes" class="headerlink" title="Customization of Module Attributes"></a>Customization of Module Attributes</h1><h1 id="Typing-Enhancements"><a href="#Typing-Enhancements" class="headerlink" title="Typing Enhancements"></a>Typing Enhancements</h1><h1 id="更精确的时间（纳秒级）"><a href="#更精确的时间（纳秒级）" class="headerlink" title="更精确的时间（纳秒级）"></a>更精确的时间（纳秒级）</h1><h1 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h1><h2 id="有序字典上升至语言规范"><a href="#有序字典上升至语言规范" class="headerlink" title="有序字典上升至语言规范"></a>有序字典上升至语言规范</h2><h2 id="async-和-await-成为关键字"><a href="#async-和-await-成为关键字" class="headerlink" title="async 和 await 成为关键字"></a><code>async</code> 和 <code>await</code> 成为关键字</h2><h2 id="asyncio-Face-Lift"><a href="#asyncio-Face-Lift" class="headerlink" title="asyncio Face Lift"></a><code>asyncio</code> Face Lift</h2><h2 id="上下文变量"><a href="#上下文变量" class="headerlink" title="上下文变量"></a>上下文变量</h2><h2 id="使用-importlib-resources-导入数据文件"><a href="#使用-importlib-resources-导入数据文件" class="headerlink" title="使用 importlib.resources 导入数据文件"></a>使用 <code>importlib.resources</code> 导入数据文件</h2><h1 id="开发者相关"><a href="#开发者相关" class="headerlink" title="开发者相关"></a>开发者相关</h1><h2 id="X-命令行参数"><a href="#X-命令行参数" class="headerlink" title="-X 命令行参数"></a><code>-X</code> 命令行参数</h2><ul><li><code>-X importtime</code> 查看模块导入时间</li><li><code>-X dev</code> 开发模式</li><li><code>-X utf8</code> UTF-8 模式</li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><ul><li>减少调用标准库中的大部分方法的开销</li><li>方法调用速度快 20%</li><li>Python 启动速度减少了 10% ~ 30%</li><li>导入 typing 模块速度快 7 倍</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://realpython.com/python37-new-features/" target="_blank" rel="noopener">Cool New Features in Python 3.7</a></li><li><a href="https://zhuanlan.zhihu.com/p/34963159" target="_blank" rel="noopener">attrs 和 Python3.7 的 dataclasses</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IPython 的正确打开方式</title>
      <link href="//IPython%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/"/>
      <url>//IPython%20%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>接触 IPython 其实已经很久了，但一直把它当做简单的 Python Shell 去用，并没有深入的研究过。直到今天调试程序的时候，发现每次修改完某个文件，都需要退出然后再进入 IPython 环境，重新导入一次模块才会生效。来回几次感觉自己特别傻，这样调试一点也不“优雅”，Google 了下才发现 IPython 里有个 <code>autoreload</code> 命令，可以自动监测文件改动，然后重新载入，这才对 IPython 刮目相看。很多时候效率低其实不是工具不好，是不会用。今天就整理一下 IPython 中的一些常用命令。</p><h1 id="自动重载"><a href="#自动重载" class="headerlink" title="自动重载"></a>自动重载</h1><p><code>autoreload</code> 主要用途是在用户执行代码块之前重新加载模块。使用效果如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: %load_ext autoreload</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: %autoreload <span class="number">2</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: <span class="keyword">from</span> foo <span class="keyword">import</span> some_function</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: some_function()</span><br><span class="line">Out[<span class="number">4</span>]: <span class="number">42</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: <span class="comment"># open foo.py in an editor and change some_function to return 43</span></span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: some_function()</span><br><span class="line">Out[<span class="number">6</span>]: <span class="number">43</span></span><br></pre></td></tr></table></figure><p>如上所示在修改完某个文件后再次调用同一方法，返回的结果不同，也不需要退出交互环境。但下次进入 IPython 的时候还是需要敲 <code>autoreload</code> 命令，所以我们可以再修改一下 IPython 的配置文件，让它每次启动的时候，自动执行 <code>autoreload</code> 命令。</p><p>如果之前没有配置过 IPython ，可以使用如下命令新建配置文件：</p><pre><code>ipython profile create</code></pre><p>如果之前配置过，可以在 <code>~/.ipython/profile_default/</code> 中（默认）修改之前的配置文件，一般命名为 <code>ipython_config.py</code> 。</p><p>在配置文件中做如下修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## lines of code to run at IPython startup.</span></span><br><span class="line">c.InteractiveShellApp.exec_lines = [<span class="string">'autoreload 2'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">## A list of dotted module names of IPython extensions to load.</span></span><br><span class="line">c.InteractiveShellApp.extensions = [<span class="string">'autoreload'</span>]</span><br></pre></td></tr></table></figure><p>这样就可以优雅的调试了😁</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p>下面介绍一些常用的命令:</p><pre><code>- run       运行 Python 脚本，每次都从磁盘读取，和导入模块不同- edit      调用编辑器进行编辑（可以配置是 Vim 还是 Emacs）- debug     调用 pdb 调试程序，可以通过参数设置断点- history   检查历史输入和输入，可以通过配置保存输出历史记录- cd        更改当前工作目录- timeit    程序执行时间- alias     定义系统命令别名- autocall  使函数可以不用输入括号来调用- bookmark  将某个目录设置为书签，下次可以直接使用 cd -b 进入- env       获取、设置或列出环境变量- lsmagic   列出可用的魔术功能- pdb       控制 pdb 调试器，具体参考 pdb 用法- pwd       返回当前工作目录- recall    重复一个命令- rehashx   获取 $PATH 中所有别名- who       打印所有交互式变量</code></pre>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于精灵方可梦</title>
      <link href="//%E5%85%B3%E4%BA%8E%E7%B2%BE%E7%81%B5%E6%96%B9%E5%8F%AF%E6%A2%A6/"/>
      <url>//%E5%85%B3%E4%BA%8E%E7%B2%BE%E7%81%B5%E6%96%B9%E5%8F%AF%E6%A2%A6/</url>
      <content type="html"><![CDATA[<p>前段时间任天堂公布了 Switch 上第一款 Pokemon 作品，叫精灵宝可梦·皮卡丘/伊布。作为一个从红绿黄开始玩的口袋妖怪粉，还是相当激动的。但今天不提这款新作，因为离发售还要好久。今天我想说的是在公布皮卡丘/伊布版本时发售的一款“尝鲜”游戏 <code>Pokemon Quest</code>，因为是像素风，所以玩家们都称其为精灵方可梦（因为真的很方啊）。</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>游戏乍看是一款像素风的弱智手游，但细看还是很精致的，Pokemon 的技能、音乐、动作都很细致。开局御三家+伊布（只能选一只），外加一只傻傻的还经常电量不足的向导，我们的探险就开始了。游戏就是一关一关的探索，随着难度的提升会奖励不同的P力石。刚开始的数值是100以下，到最后（我通关的时候），可以爆到900+的数值。分 ATK 和 HP 两种，可以镶嵌在 Pokemon 对应的P力孔上。每一关除了奖励P力石，还会奖励各种料理材料，有红黄蓝灰彩10多种，用锅煮不同种类、数量的料理，会吸引不同等级、种类的宝可梦。锅也是分等级的，有四种，最高级是金锅，煮出的料理可以吸引等级80+，并且个体值都很高的 Pokemon. </p><h1 id="一点攻略"><a href="#一点攻略" class="headerlink" title="一点攻略"></a>一点攻略</h1><p>这个游戏说是选择 Pokemon ，培养队伍，其实是选择技能。三只 Pokemon 要互相搭配，前期的话可以考虑大岩蛇神教，1只带3孔变硬，其他2只3孔落石，基本可以无痛推到第10关。挂机最稳定的是1DPS+2辅助。<br>技能选择如下：</p><ul><li>DPS<ul><li>百万吨拳击（一般系）</li><li>水炮（水系）</li><li>落石（地面系、岩石系）</li><li>藤鞭（草系）</li><li>流星群（龙系）</li></ul></li><li>辅助<ul><li>变硬（加防御）</li><li>缩壳（加防御）</li><li>健美（加攻击力、防御）</li><li>屏障（加防御）</li><li>…</li></ul></li></ul><p>我的队伍配置是一只3孔流星群的快龙（洗了好多只迷你龙才出），加一只3孔缩壳菊石兽，一只3孔健美怪力。快龙吸血5% ，怪力吸血5% 。</p><p>喜欢流星群是觉得酷炫伤害又高，是快龙的专属技能。简直是移动的轰炸机😂不过最稳定的挂机配置应该是单水炮+双健美，各种 12-9 2分钟内解决。我最后通关的战力是26000左右，感觉还是蛮脆的，Buff 没叠好超梦一炮就把我的快龙KO掉了，而且流星群命中率面对移速高的 Boss 太低了，虽然伤害爆炸。所以还是水炮稳定。</p><h1 id="评价"><a href="#评价" class="headerlink" title="评价"></a>评价</h1><p>总的来说，这款小巧精致的手游还蛮有意思的，再收集收集全图鉴，开发开发新的配置，也能玩个百来小时。反正我是肝不动，自从上次花了半年把太阳版的全国图鉴集齐，肝儿已经废了。这类游戏通关就脱坑。接下来就是等伊布/皮卡丘版发售啦😝</p>]]></content>
      
      
        <tags>
            
            <tag> game </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spacemacs 使用小记</title>
      <link href="//Spacemacs%20%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/"/>
      <url>//Spacemacs%20%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>Mac 自带的 Emacs 仅为终端版本，我一般会腾出终端窗口另做他用，所以先安装图形界面的 Emacs 。图形界面的版本有很多，比如<code>emacs-plus</code>，<code>emacs-mac</code>等，我喜欢 Homebrew 推荐的 cask 版本。安装如下（需要事先安装好 Homebrew ）：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># brew 安装 emacs</span><br><span class="line">brew cask install emacs</span><br></pre></td></tr></table></figure><p>然后从 GitHub 下载 Spacemacs 的开发版本。如需安装稳定版请 git master 分支。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 安装 Spacemacs devlop 分支</span><br><span class="line">rm -rf ~/.emacs.d</span><br><span class="line">git clone -b develop https://github.com/syl20bnr/spacemacs ~/.emacs.d</span><br></pre></td></tr></table></figure><p>打开新安装的 Emacs，会提示选择 vim 还是 emacs 操作习惯，然后选择插件的默认依赖，选择 <code>spacemacs</code> 就可以。这时会在用户目录生成 <code>.spacemacs</code>配置文件，并开始从 melpa.org 等站点下载依赖包。下载速度会很慢，所以此时强制退出。我们先替换 melpa\org\gnu 为国内源以提高安装速度。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 清空 elpa 目录</span><br><span class="line">rm -rf ~/.emacs.d/elpa/</span><br><span class="line"></span><br><span class="line"># 打开 Spacemacs 配置文件</span><br><span class="line">vim ~/.spacemacs</span><br></pre></td></tr></table></figure><p>找到<code>(defun dotspacemacs/user-init ()</code>并在其中添加以下代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">setq</span> configuration-layer-elpa-archives</span><br><span class="line">    '((<span class="string">"melpa-cn"</span> . <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/"</span>)</span><br><span class="line">      (<span class="string">"org-cn"</span>   . <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/org/"</span>)</span><br><span class="line">      (<span class="string">"gnu-cn"</span>   . <span class="string">"http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/"</span>)))</span><br></pre></td></tr></table></figure><p>保存退出后重启 Emacs 等待安装完成。</p><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>为了便于管理自己的配置文件，可以将<code>.spacemacs</code>配置文件改名为<code>init.el</code>放置在<code>.spacemacs.d</code>文件夹中方便上传至 Github ，我的配置文件可以<a href="https://github.com/zhd173/.spacemacs.d" target="_blank" rel="noopener">参考这里</a></p><p>打开 Emacs 后，就可以看到 Spacemacs 骚骚的基佬紫了。在 Spacemacs 中修改配置文件可以使用快捷键 <code>SPC f e d</code> ，SPC 指的是空格，是 Spacemacs 默认的 Leader 键。</p><h2 id="添加-Layer"><a href="#添加-Layer" class="headerlink" title="添加 Layer"></a>添加 Layer</h2><p>Spacemacs 通过组合不同的 Layer 来添加不同的功能。可以在 <code>dotspacemacs-configuration-layers</code> 添加。列出基础 Python 需要的 Layers 供参考：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">dotspacemacs-configuration-layers</span><br><span class="line">'(</span><br><span class="line">  ;; ----------------------------------------------------------------</span><br><span class="line">  ;; Example of useful layers you may want to use right away.</span><br><span class="line">  ;; Uncomment some layer names and press `SPC f e R' (Vim style) or</span><br><span class="line">  ;; `M-m f e R' (Emacs style) to install them.</span><br><span class="line">  ;; ----------------------------------------------------------------</span><br><span class="line">  helm</span><br><span class="line">  (python :variables</span><br><span class="line">          python-test-runner 'pytest</span><br><span class="line">          python-fill-column <span class="number">79</span></span><br><span class="line">          )</span><br><span class="line">  (auto-completion :variables</span><br><span class="line">                   auto-completion-enable-sort-by-usage <span class="literal">t</span></span><br><span class="line">                   auto-completion-enable-snippets-in-popup <span class="literal">t</span></span><br><span class="line">                   )</span><br><span class="line">  emacs-lisp</span><br><span class="line">  git</span><br><span class="line">  markdown</span><br><span class="line">  neotree</span><br><span class="line">  emoji</span><br><span class="line">  syntax-checking</span><br><span class="line">  version-control</span><br><span class="line">  )</span><br></pre></td></tr></table></figure><h2 id="其他设置"><a href="#其他设置" class="headerlink" title="其他设置"></a>其他设置</h2><p>可以在用户自定义配置 <code>defun dotspacemacs/user-config ()</code> 中设置一些变量，比如 PATHONPATH ，或者通过 <code>(setq custom-file ))</code> 导入自定义的配置文件。参考如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">(<span class="name">defun</span> dotspacemacs/user-config ()</span><br><span class="line">  <span class="string">"Configuration for user code:</span></span><br><span class="line"><span class="string">This function is called at the very end of Spacemacs startup, after layer</span></span><br><span class="line"><span class="string">configuration.</span></span><br><span class="line"><span class="string">Put your configuration code here, except for variables that should be set</span></span><br><span class="line"><span class="string">before packages are loaded."</span></span><br><span class="line">  (<span class="name">setq</span> neo-theme 'icons)</span><br><span class="line">  (<span class="name">setq</span> importmagic-python-interpreter <span class="string">"ipython"</span>)</span><br><span class="line">  (<span class="name">setq</span> python-shell-interpreter <span class="string">"ipython"</span></span><br><span class="line">        python-shell-interpreter-args <span class="string">"--simple-prompt -i"</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line"><span class="comment">;; Do not write anything past this comment. This is where Emacs will</span></span><br><span class="line"><span class="comment">;; auto-generate custom variable definitions.</span></span><br><span class="line">(<span class="name">setq</span> custom-file (<span class="name">expand-file-name</span> <span class="string">"custom.el"</span> dotspacemacs-directory))</span><br><span class="line">(<span class="name">load</span> custom-file 'no-error 'no-message)</span><br><span class="line">(<span class="name">defun</span> dotspacemacs/emacs-custom-settings ()</span><br><span class="line">  <span class="string">"Emacs custom settings.</span></span><br><span class="line"><span class="string">This is an auto-generated function, do not modify its content directly, use</span></span><br><span class="line"><span class="string">Emacs customize menu instead.</span></span><br><span class="line"><span class="string">This function is called at the very end of Spacemacs initialization."</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于 Celery 提示任务未注册的解决办法</title>
      <link href="//%E5%85%B3%E4%BA%8E%20Celery%20%E6%8F%90%E7%A4%BA%E4%BB%BB%E5%8A%A1%E6%9C%AA%E6%B3%A8%E5%86%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>//%E5%85%B3%E4%BA%8E%20Celery%20%E6%8F%90%E7%A4%BA%E4%BB%BB%E5%8A%A1%E6%9C%AA%E6%B3%A8%E5%86%8C%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h1><p>今天工作中碰到了这个问题。抽空记录一下。在用 <code>celery.task</code> 装饰器装饰了定时任务的方法后，启动 <code>worker</code> 进程在任务列表中找不到新增的任务。并且在执行任务时报错，信息如下：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2018</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">15</span>:<span class="number">57</span>:<span class="number">52</span>,<span class="number">340</span>: INFO/MainProcess] celery@worker-<span class="number">00</span> ready.</span><br><span class="line">[<span class="number">2018</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">15</span>:<span class="number">57</span>:<span class="number">52</span>,<span class="number">343</span>: ERROR/MainProcess] Received unregistered task of <span class="built_in">type</span> 'tasks.reports.reports_data_collect'.</span><br><span class="line">The message has been ignored and discarded.</span><br><span class="line"></span><br><span class="line">Did you remember to import the module containing this task?</span><br><span class="line">Or maybe you're using relative imports?</span><br><span class="line"></span><br><span class="line">Please see</span><br><span class="line"><span class="function">http://<span class="title">docs.celeryq.org</span>/<span class="title">en</span>/<span class="title">latest</span>/<span class="title">internals</span>/<span class="title">protocol.html</span></span></span><br><span class="line"><span class="function"><span class="title">for</span> <span class="title">more</span> <span class="title">information</span>.</span></span><br></pre></td></tr></table></figure><h1 id="主要原因"><a href="#主要原因" class="headerlink" title="主要原因"></a>主要原因</h1><p>经过分析主要原因是新增的定时任务没有加载至内存中。之前自己写的其他 <code>Celery</code> 任务没有出现这些问题是因为在某个地方导入并调用过。而这次新增的定时任务是写在新建的 <code>.py</code> 文件中，且没有在其他地方 <code>import</code> 过。所以任务在执行时会提示该任务未注册。</p><h1 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h1><p>在 Django 中只要在配置文件中加入以下参数即可解决。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Celery</span></span><br><span class="line">CELERY_IMPORTS = (<span class="string">'some.new.tasks'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于练字</title>
      <link href="//%E5%85%B3%E4%BA%8E%E7%BB%83%E5%AD%97/"/>
      <url>//%E5%85%B3%E4%BA%8E%E7%BB%83%E5%AD%97/</url>
      <content type="html"><![CDATA[<h1 id="关于练字"><a href="#关于练字" class="headerlink" title="关于练字"></a>关于练字</h1><p>我从小就喜欢练字，兴趣大概始于四岁。那时候和爷爷奶奶一起住，爷爷做农活的时候总带着我。每日在往返家里那几块老地的时候，我总是跑在前面，在田埂上用随地捡的麦梗树枝练习爷爷教的字。一笔一划的细心写完，爷爷正好走到跟前，端详之后总会说哪里不对，哪里写反了（比如我总是写反“四”字里面的那两笔）。<br>爷爷在屋里得空的时候，也会用废报纸、废书教我写毛笔字。后来上了学，小学语文老师的板书写得特别漂亮。在我们读课文的时候，她会在黑板上信手写一些诗句然后擦掉，如此重复。我时常看老师写字而忘记背课文。每天的田字格作业我都会很认真的写，想和老师写得一样好看。<br>如今大学毕业，工作已经快两年，闲来无事的时候喜欢随便拿些纸笔，和小学语文老师那样随手写一些字句。这样能使人心静，不会有大城市普遍都有的焦虑了。</p><p>以前总对草书很感兴趣，高中的时候临过老家县城一位小有名气的爷爷出的字帖，感觉连笔写出来的字都好看，尤其在别人都看不懂的时候。现在想来，那时候真是不懂事。在自己还没有完全打好基础的时候，盲目去追求连笔、精简笔画，久而久之字就会变形，整体的章法也变的潦草。人也开始变的浮躁、急于求成。<br>就像你偶然发现了一条捷径，手足舞蹈地走到头，在向众人炫耀你已经到达终点的时候，发现自己竟然走的是一条错路，像小丑一样。</p><p><strong>所以不能忽视基础，不能着急，不能炫耀，不管写字还是工作。</strong></p><p>这篇文章本想只做一份字帖的清单，供参考。没想到关于写字自己也可以说这么多。前面说道不能忽视基础，在写字方面，就是不能忽视真楷。近两年，我越来越喜欢楷书，认为那才是真正的美。在公众号、抖音上看到一些所谓的 “丑书” ，看到一些信笔的“涂鸦”，总是无感。反而是那些认真写楷书的人，我会更欣赏。当然不是说其他字体不美，只是自己的功力未到，写行书、草书总会感觉少了很多内在的东西，华而不实。</p><h1 id="关于字帖"><a href="#关于字帖" class="headerlink" title="关于字帖"></a>关于字帖</h1><p>这里罗列一些自己喜欢的字帖。只有楷书。</p><pre><code>- 《多宝塔碑》颜真卿- 《颜卿礼碑》颜真卿- 《灵飞经》钟绍京- 《琴赋》文征明- 《吴氏重修祠堂记》徐元礼- 《滕王阁序》高垲</code></pre>]]></content>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Celery 定时任务的启动方式</title>
      <link href="//Celery%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/"/>
      <url>//Celery%20%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F/</url>
      <content type="html"><![CDATA[<p>工作中踩了一些坑，抽空整理了一下。现阶段启动 <code>celery beat</code>一般有两种方式:</p><h1 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h1><p>  在生产环境中推荐使用这种方式。可以在<code>supervisor</code>中新增一个配置文件来启动。并在<code>ansible</code>配置文件中添加重启项目。</p>  <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ celery -A proj beat</span><br></pre></td></tr></table></figure><p>  Beat 服务需要一个地方存储上次定时任务运行的时间（默认名为<code>celerybeat-schedule</code>，是一个本地<code>shelve</code>数据库文件），所以要确保 Beat 在该文件所在的目录有写权限。否则会因为权限报错。可以通过以下命令指定<code>celerybeat-schedule</code>目录：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ celery -A proj beat -s /home/celery/var/run/celerybeat-schedule</span><br></pre></td></tr></table></figure><h1 id="在启动-Worker-时增加参数"><a href="#在启动-Worker-时增加参数" class="headerlink" title="在启动 Worker 时增加参数"></a>在启动 Worker 时增加参数</h1><p>  虽然这种方式在只启动一个 <code>worker</code> 节点的时候很方便，但通常在生产环境中不推荐这种方式。因为生产环境常常启动多个 <code>worker</code> 节点，这种启动方式会导致每个<code>worker</code>节点都启动一个<code>beat</code>服务，可能会重复执行事先做好的定时任务。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ celery -A proj worker -B</span><br></pre></td></tr></table></figure><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="使用-Django-插件"><a href="#使用-Django-插件" class="headerlink" title="使用 Django 插件"></a>使用 Django 插件</h2><p>  默认的调度程序用本地的<code>shelve</code>数据库文件来储存定时任务上次运行的时间，使用<code>django-celery-beat</code>可以将这些信息储存在 Django 数据库中。</p><ul><li><p>安装包</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install django-celery-beat</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>在配置文件中将改包加入<code>INSTALLED_APPS</code>配置项中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = (</span><br><span class="line">  ...,</span><br><span class="line">  <span class="string">'django_celery_beat'</span>,</span><br><span class="line">)</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">- 运行 Django 数据库迁移来创建表</span><br><span class="line"></span><br><span class="line">```cmd</span><br><span class="line">$ python manage.py migrate</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>调用 Beat 时使用参数</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ celery -A proj beat -l info --scheduler django_celery_beat.schedulers:DatabaseScheduler</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>我的时间&amp;知识管理方法论</title>
      <link href="//%E6%88%91%E7%9A%84%E6%97%B6%E9%97%B4&amp;%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/"/>
      <url>//%E6%88%91%E7%9A%84%E6%97%B6%E9%97%B4&amp;%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E8%AE%BA/</url>
      <content type="html"><![CDATA[<h2 id="1-通勤时间段"><a href="#1-通勤时间段" class="headerlink" title="1. 通勤时间段"></a>1. 通勤时间段</h2><ul><li>阅读文学类、历史类书籍，阅读计划、完成进度每日在 <code>OmniFocus - Reading</code> 项目中更新。每本书最好都整理笔记或者读后感进 <code>Quiver</code> 。</li></ul><h2 id="2-上班时间段"><a href="#2-上班时间段" class="headerlink" title="2. 上班时间段"></a>2. 上班时间段</h2><ul><li>琐事进入 <code>OmniFocus - 收件箱</code> 进行管理。添加时评估完成时间，小于30分钟的立即完成。</li><li>工作项目进入 <code>OmniFocus - Botpy</code> 进行管理。重点项目优先完成。尽量将动作分解为最小粒度，评估时间后设置 Deadline 。临近 Deadline 时若工作未完成，可寻求帮助或适当延期。实在无法完成可暂时跳过，切勿耽误接下来的工作。</li><li>手头已有安排的工作，应尽量避免长时间浏览与工作不相关的网页与视频，包括技术博客和官方文档。</li><li>手头暂时没有安排的工作，可按照 <code>OmniFocus - Learning</code> 项目中制定的计划学习新的知识，项目中动作的结束标志为是否将学习笔记整理进 <code>Quiver</code> 。</li><li>对于工作过程中的碎片知识、感悟、技巧应及时记录在 <code>Quiver - Daily</code> 中。</li></ul><h2 id="3-周末-amp-假期"><a href="#3-周末-amp-假期" class="headerlink" title="3. 周末&amp;假期"></a>3. 周末&amp;假期</h2><ul><li>优先整理本周（月）的笔记和计划</li><li>完成本周（月）未完成的计划</li><li>写读后感、整理笔记、写游戏评论</li><li>更新博客</li><li>以上都做完，没有其他出行安排，再打游戏😭</li></ul><p><strong>最重要的：坚持✊</strong></p>]]></content>
      
      
        <tags>
            
            <tag> other </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Django QuerySet API 整理</title>
      <link href="//Django%20%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>//Django%20%E6%A8%A1%E5%9E%8B%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>（译自官方文档）</p><h1 id="以下操作会真正操作数据库"><a href="#以下操作会真正操作数据库" class="headerlink" title="以下操作会真正操作数据库"></a>以下操作会真正操作数据库</h1><ul><li>Iteration：在遍历对象时就会执行数据库操作</li><li>Slicing：对与一个未查询的 QuerySet 切片就会返回另一个未查询的 QuerySet 。使用参数 <code>step</code> 参数时会执行数据库操作</li><li>Picking/Caching：参见 Picking QuerySet</li><li>repr()：调用该方法时查询会被运行，并可以立即看到查询结果（命令行常用）</li><li>len()：返回查询结果列表的长度。运行时执行数据库操作，使用 <code>count()</code> 会更加高效</li><li>list()：再转化为列表时会执行数据库操作，且占用大量内存。而遍历 QuerySet 时仅使用某个对象时才加载至内存中</li></ul><h1 id="Picking-QuerySet"><a href="#Picking-QuerySet" class="headerlink" title="Picking QuerySet"></a>Picking QuerySet</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line">query = pickle.loads(s)     <span class="comment"># Assuming 's' is the pickled string.</span></span><br><span class="line">qs = MyModel.objects.all()</span><br><span class="line">qs.query = query            <span class="comment"># Restore the original 'query'.</span></span><br></pre></td></tr></table></figure><h1 id="QuerySet-API"><a href="#QuerySet-API" class="headerlink" title="QuerySet API"></a>QuerySet API</h1><ul><li>filter(**kwargs)：根据筛选条件返回相匹配的对象。参见 Filed lookups</li><li>exclued(**kwargs)：根据筛选条件返回不匹配的对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.exclude(pub_date__gt=datetime.date(<span class="number">2005</span>, <span class="number">1</span>, <span class="number">3</span>), headline=<span class="string">'Hello'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT ...</span><br><span class="line">WHERE NOT (pub_date &gt; &apos;2005-1-3&apos; AND headline = &apos;Hello&apos;)</span><br></pre></td></tr></table></figure><ul><li>annotate(<em>args,*</em>kwargs)：为 QuerySet 中的每个对象添加注解（可以理解为辅助计算列），具体的函数参见 Aggregation Functions</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Blog.objects.annotate(number_of_entries=Count(<span class="string">'entry'</span>))</span><br><span class="line"><span class="comment"># The number of entries on the first blog, using the name provided</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q[<span class="number">0</span>].number_of_entries</span><br><span class="line"><span class="number">42</span></span><br></pre></td></tr></table></figure><ul><li>order_by(*fileds)：默认情况下，QuerySet 返回的查询结果以 Model 类的 Meta 设置所提供的 <code>ordering</code> 项中定义的排序元组来排序。可以使用 <code>order_by</code> 进行覆盖。通过设置 QuerySet.ordered 属性，可以决定某个查询是否可排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 🌰：以 pub_date 升序，再以 headline 倒序，默认倒序</span></span><br><span class="line">Entry.objects.filter(pub_date__year=<span class="number">2005</span>).order_by(<span class="string">'-pub_date'</span>, <span class="string">'headline'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机排序（占用较多资源）</span></span><br><span class="line">Entry.objects.order_by(<span class="string">'?'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据其他 Model 类的字段排序，若没有指定字段，默认会采用 Meta.ordering 进行排序。否则会以主键排序</span></span><br><span class="line">Entry.objects.order_by(<span class="string">'blog__name'</span>, <span class="string">'headline'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以使用 asc() 和 desc() 方法</span></span><br><span class="line">Entry.objects.order_by(Coalesce(<span class="string">'summary'</span>, <span class="string">'headline'</span>).desc())</span><br></pre></td></tr></table></figure><ul><li>reverse()：对查询结果进行反向排序</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 得到查询结果中最后五个对象</span></span><br><span class="line">my_queryset.reverse()[:<span class="number">5</span>]</span><br></pre></td></tr></table></figure><ul><li>distinct()：返回一个新的 QuerySet ,在执行查询时使用 select distinct. 默认情况下，QuerySet 会自动剔除重复的记录，但是在多表查询时，可能会用到 Distinct(慎用)</li><li>values(*fields)：返回一个 ValuesQuerySet ，运行后得到的不是 Model 的实例话对象，而是一个可迭代的字典序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># This list contains a Blog object.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.filter(name__startswith=<span class="string">'Beatles'</span>)</span><br><span class="line">[&lt;Blog: Beatles Blog&gt;]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># This list contains a dictionary.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.filter(name__startswith=<span class="string">'Beatles'</span>).values()</span><br><span class="line">[&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>, <span class="string">'tagline'</span>: <span class="string">'All the latest Beatles news.'</span>&#125;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 入参可以指定字段，限定 Select 选取的数据</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values()</span><br><span class="line">[&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>, <span class="string">'tagline'</span>: <span class="string">'All the latest Beatles news.'</span>&#125;],</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.values(<span class="string">'id'</span>, <span class="string">'name'</span>)</span><br><span class="line">[&#123;<span class="string">'id'</span>: <span class="number">1</span>, <span class="string">'name'</span>: <span class="string">'Beatles Blog'</span>&#125;]</span><br><span class="line"><span class="comment">#</span></span><br></pre></td></tr></table></figure><ul><li>values_list(*fields)：与 values() 类似，不过返回的是元组序列</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'id'</span>, <span class="string">'headline'</span>)</span><br><span class="line">[(<span class="number">1</span>, <span class="string">u'First entry'</span>), ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果传递了一个字段做为参数，那么使用 flat 参数(值为 True），就意味着返回结果都是单独的值，而不是元组。如下：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'id'</span>).order_by(<span class="string">'id'</span>)</span><br><span class="line">[(<span class="number">1</span>,), (<span class="number">2</span>,), (<span class="number">3</span>,), ...]</span><br><span class="line"> </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.values_list(<span class="string">'id'</span>, flat=<span class="keyword">True</span>).order_by(<span class="string">'id'</span>)</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ...]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 注意这个方法返回的是 ValuesListQuerySet对象，和列表相似但并不是列表，需要列表操作时需list()转为列表。</span></span><br></pre></td></tr></table></figure><ul><li>dates(field , kind , order=’ASC’)：返回一个DateQuerySet，提取 QuerySet 查询中所包含的日期，组成一个新的 datetime.date 对象列表</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'year'</span>)</span><br><span class="line">[datetime.date(<span class="number">2005</span>, <span class="number">1</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'month'</span>)</span><br><span class="line">[datetime.date(<span class="number">2005</span>, <span class="number">2</span>, <span class="number">1</span>), datetime.date(<span class="number">2005</span>, <span class="number">3</span>, <span class="number">1</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'day'</span>)</span><br><span class="line">[datetime.date(<span class="number">2005</span>, <span class="number">2</span>, <span class="number">20</span>), datetime.date(<span class="number">2005</span>, <span class="number">3</span>, <span class="number">20</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.dates(<span class="string">'pub_date'</span>, <span class="string">'day'</span>, order=<span class="string">'DESC'</span>)</span><br><span class="line">[datetime.date(<span class="number">2005</span>, <span class="number">3</span>, <span class="number">20</span>), datetime.date(<span class="number">2005</span>, <span class="number">2</span>, <span class="number">20</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.filter(headline__contains=<span class="string">'Lennon'</span>).dates(<span class="string">'pub_date'</span>, <span class="string">'day'</span>)</span><br><span class="line">[datetime.date(<span class="number">2005</span>, <span class="number">3</span>, <span class="number">20</span>)]</span><br></pre></td></tr></table></figure><ul><li>datetimes(field , kind , order=’ASC’)：返回一个 DateTimeQuerySet ,组成一个新的 datetime.datetime 对象列表</li><li>none()：返回一个 EmptyQuerySet ,在运行时只返回一个空列表。适用于你要返回一个空列表，但调用者却需要接收一个 QuerySet 对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.none()</span><br><span class="line">[]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models.query <span class="keyword">import</span> EmptyQuerySet</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(Entry.objects.none(), EmptyQuerySet)</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><ul><li>all()：返回当前 QuerySet 但一份拷贝。当 QuerySet 运行后，会缓存查询结果，如果数据库发生了改变，调用 all() 可以更新查询</li><li>select_related()：返回一个 QuerySet ，在执行查询时进口可能深入的遍历外键关系，再查询后再使用外键关系获取关联对象时不会再读取数据库（通过库内 Join 进行查询）</li><li>prefetch_related()：与 select_related() 类似，但是是分别查询每个表，然后用 Python 处理他们之间的关系</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Topping</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">30</span>)</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pizza</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">50</span>)</span><br><span class="line">    toppings = models.ManyToManyField(Topping)</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span>              <span class="comment"># __unicode__ on Python 2</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"%s (%s)"</span> % (self.name, <span class="string">", "</span>.join([topping.name</span><br><span class="line">                                                  <span class="keyword">for</span> topping <span class="keyword">in</span> self.toppings.all()]))</span><br><span class="line">                                                  </span><br><span class="line">                                                  </span><br><span class="line">                                                  </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Pizza.objects.all().prefetch_related(<span class="string">'toppings'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Restaurant</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    pizzas = models.ManyToMany(Pizza, related_name=<span class="string">'restaurants'</span>)</span><br><span class="line">    best_pizza = models.ForeignKey(Pizza, related_name=<span class="string">'championed_by'</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Restaurant.objects.prefetch_related(<span class="string">'pizzas__toppings'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Restaurant.objects.prefetch_related(<span class="string">'best_pizza__toppings'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Restaurant.objects.select_related(<span class="string">'best_pizza'</span>).prefetch_related(<span class="string">'best_pizza__toppings'</span>)</span><br></pre></td></tr></table></figure><ul><li>extra(select=None,where=None,params=None,tables=None,order_by=None,select_params=None)<br>extra() 可以修改 QuerySet ,能在生成的SQL语句中注入新的子句。但应尽量避免写 extra ,因为违背了 DRY 原则</li><li>defer(*field)：将不想载入但字段传给 defer() 方法，可以做到延后载入</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.defer(<span class="string">"lede"</span>, <span class="string">"body"</span>)</span><br><span class="line"></span><br><span class="line">Entry.objects.defer(<span class="string">"body"</span>).filter(headline=<span class="string">"Lennon"</span>).defer(<span class="string">"lede"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以延迟载入关联 Model 中的字段，前提是使用 select_related() 载入了关联 Model</span></span><br><span class="line">Blog.objects.select_related().defer(<span class="string">"entry__lede"</span>, <span class="string">"entry__body"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除延后载入设置，传入 None</span></span><br><span class="line">my_queryset.defer(<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><ul><li>only(*field)：和 defer() 作用相反，立即载入可以使用 only()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Person.objects.defer(<span class="string">"age"</span>, <span class="string">"biography"</span>)</span><br><span class="line">Person.objects.only(<span class="string">"name"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连续调用只有最后一个 only() 会生效</span></span><br><span class="line">Entry.objects.only(<span class="string">"body"</span>, <span class="string">"lede"</span>).only(<span class="string">"headline"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以结合 defer() 一起使用，先 only 后 defer</span></span><br><span class="line"><span class="comment"># Final result is that everything except "headline" is deferred.</span></span><br><span class="line">Entry.objects.only(<span class="string">"headline"</span>, <span class="string">"body"</span>).defer(<span class="string">"body"</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># Final result loads headline and body immediately (only() replaces any</span></span><br><span class="line"><span class="comment"># existing set of fields).</span></span><br><span class="line">Entry.objects.defer(<span class="string">"body"</span>).only(<span class="string">"headline"</span>, <span class="string">"body"</span>)</span><br></pre></td></tr></table></figure><ul><li>using(alias)：切换数据库，参数是数据库的alias</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># queries the database with the 'default' alias.</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.all()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># queries the database with the 'backup' alias</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.using(<span class="string">'backup'</span>)</span><br></pre></td></tr></table></figure><ul><li>select_for_update(nowait=False)：返回queryset，并将需要更新的行锁定，类似于SELECT … FOR UPDATE的操作</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entries = Entry.objects.select_for_update().filter(author=request.user)</span><br></pre></td></tr></table></figure><ul><li>raw(raw_query, params=None, translations=None)：执行 Raw SQL 查询</li></ul><h1 id="不返回查询的方法"><a href="#不返回查询的方法" class="headerlink" title="不返回查询的方法"></a>不返回查询的方法</h1><p>这些方法不使用缓存，他们在运行时是直接读取数据库的。</p><ul><li>get(**kwargs)：返回与筛选条件相匹配的对象。返回对象超过一个，抛出 MultipleObjectsReturned 异常，没有返回对象返回 DoesNotExist 异常</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># DoesNotExist 异常继承自 django.core.exceptions.ObjectDoesNotExist，可以直接截获 DoesNotExist 异常</span></span><br><span class="line"><span class="keyword">from</span> django.core.exceptions <span class="keyword">import</span> ObjectDoesNotExist</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    e = Entry.objects.get(id=<span class="number">3</span>)</span><br><span class="line">    b = Blog.objects.get(id=<span class="number">1</span>)</span><br><span class="line"><span class="keyword">except</span> ObjectDoesNotExist:</span><br><span class="line">    print(<span class="string">"Either the entry or blog doesn't exist."</span>)</span><br></pre></td></tr></table></figure><ul><li>create(**kwargs)：创建对象并保存</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下操作等效</span></span><br><span class="line">p = Person.objects.create(first_name=<span class="string">"Bruce"</span>, last_name=<span class="string">"Springsteen"</span>)</span><br><span class="line"></span><br><span class="line">p = Person(first_name=<span class="string">"Bruce"</span>, last_name=<span class="string">"Springsteen"</span>)</span><br><span class="line">p.save(force_insert=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 手动指定主键时，要处理好同主键的异常</span></span><br></pre></td></tr></table></figure><ul><li>get_or_create(default=None,**kwargs)：根据筛选条件查询对象，若不存在就创建一个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下代码效果相同，知识第一种过于臃肿</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    obj = Person.objects.get(first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>)</span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line">    obj = Person(first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>, birthday=date(<span class="number">1940</span>, <span class="number">10</span>, <span class="number">9</span>))</span><br><span class="line">    obj.save()</span><br><span class="line">    </span><br><span class="line">obj, created = Person.objects.get_or_create(first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>,</span><br><span class="line">                  defaults=&#123;<span class="string">'birthday'</span>: date(<span class="number">1940</span>, <span class="number">10</span>, <span class="number">9</span>)&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># defaults 只能在创建时对对象赋值，而不能进行查询</span></span><br><span class="line">Foo.objects.get_or_create(defaults__exact=<span class="string">'bar'</span>, defaults=&#123;<span class="string">'defaults'</span>: <span class="string">'baz'</span>&#125;)</span><br></pre></td></tr></table></figure><ul><li>update_or_create(defaults=None,**kwargs)：与 get_or_create() 类似</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    obj = Person.objects.get(first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> updated_values.iteritems():</span><br><span class="line">        setattr(obj, key, value)</span><br><span class="line">    obj.save()</span><br><span class="line"><span class="keyword">except</span> Person.DoesNotExist:</span><br><span class="line">    updated_values.update(&#123;<span class="string">'first_name'</span>: <span class="string">'John'</span>, <span class="string">'last_name'</span>: <span class="string">'Lennon'</span>&#125;)</span><br><span class="line">    obj = Person(**updated_values)</span><br><span class="line">    obj.save()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 可以简化为</span></span><br><span class="line"></span><br><span class="line">obj, created = Person.objects.update_or_create(</span><br><span class="line">    first_name=<span class="string">'John'</span>, last_name=<span class="string">'Lennon'</span>, defaults=updated_values)</span><br></pre></td></tr></table></figure><ul><li>bulk_create(objs,batch_size=None)：批量创建</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Entry.objects.bulk_create([</span><br><span class="line"><span class="meta">... </span>    Entry(headline=<span class="string">"Django 1.0 Released"</span>),</span><br><span class="line"><span class="meta">... </span>    Entry(headline=<span class="string">"Django 1.1 Announced"</span>),</span><br><span class="line"><span class="meta">... </span>    Entry(headline=<span class="string">"Breaking: Django is awesome"</span>)</span><br><span class="line"><span class="meta">... </span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优于</span></span><br><span class="line"></span><br><span class="line">Entry.objects.create（headline=<span class="string">"Python 1.0 Released"</span>）</span><br><span class="line">Entry.objects.create（headline=<span class="string">"Python 1.1 Planned"</span>）</span><br></pre></td></tr></table></figure><ul><li>count()：返回数据库中匹配查询的对象数量，不会抛出任何异常</li><li>in_bulk(id_list)：接收一个主键值列表，然后根据每个主键值所其对应的对象，返回一个主键值与对象的映射字典</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([<span class="number">1</span>])</span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&#123;<span class="number">1</span>: &lt;Blog: Beatles Blog&gt;, <span class="number">2</span>: &lt;Blog: Cheddar Talk&gt;&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Blog.objects.in_bulk([])</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><ul><li>iterator()：运行查询，根据结果返回一个迭代器。分多次对数据实例化，用到时才会实例化。使用迭代器效率更高，节省内存</li><li>latest(field_name=None)：根据时间字段 field_name 得到最新的对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.latest(<span class="string">'pub_date'</span>)</span><br></pre></td></tr></table></figure><ul><li>earliest(field_name=None)：根据时间字段 field_name 得到最旧（早）的对象</li><li><p>first()：排序后对第一个对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = Article.objects.order_by(<span class="string">'title'</span>, <span class="string">'pub_date'</span>).first()</span><br></pre></td></tr></table></figure></li><li><p>last()：类似于 first()</p></li><li>aggregate(<em>args, *</em>kwargs)：通过对 QuerySet 进行计算，返回一个聚合值的字典。 aggregate() 中每个参数都指定一个包含在字典中的返回值。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Count</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Blog.objects.aggregate(Count(<span class="string">'entry'</span>))</span><br><span class="line">&#123;<span class="string">'entry__count'</span>: <span class="number">16</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定返回对聚合名称</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>q = Blog.objects.aggregate(number_of_entries=Count(<span class="string">'entry'</span>))</span><br><span class="line">&#123;<span class="string">'number_of_entries'</span>: <span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>exists()：查询是否有值，返回布尔值</li><li>update()：更新</li><li>delete()：删除</li></ul><h1 id="字段筛选条件（Field-Lookups）"><a href="#字段筛选条件（Field-Lookups）" class="headerlink" title="字段筛选条件（Field Lookups）"></a>字段筛选条件（Field Lookups）</h1><p>字段筛选条件决定了你如何构造 SQL 语句中的 WHERE 从句。它们被指定为 QuerySet 中 filter()，exclude() 和 get() 方法的关键字参数。</p><ul><li>exact()：精确匹配，指定为 None 值会翻译为 SQL 中对 Null</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.get(id__exact=<span class="number">14</span>)</span><br><span class="line">Entry.objects.get(id__exact=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><ul><li>iexact()：忽略大小写的匹配，SQLite 对 Unicode 字符串，无法做忽略大小写的匹配。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Blog.objects.get(name__iexact=<span class="string">'beatles blog'</span>)</span><br><span class="line">Blog.objects.get(name__iexact=<span class="keyword">None</span>)</span><br></pre></td></tr></table></figure><ul><li>contains()：大小写敏感的包含匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.get(headline__contains=<span class="string">'Lennon'</span>)</span><br></pre></td></tr></table></figure><ul><li>icontains()：忽略大小写敏感的包含匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.get(headline__icontains=<span class="string">'Lennon'</span>)</span><br></pre></td></tr></table></figure><ul><li>in：是否在给定的列表中</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(id__in=[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">inner_qs = Blog.objects.filter(name__contains=<span class="string">'Cheddar'</span>)</span><br><span class="line">entries = Entry.objects.filter(blog__in=inner_qs)</span><br><span class="line"></span><br><span class="line">inner_qs = Blog.objects.filter(name__contains=<span class="string">'Ch'</span>).values(<span class="string">'name'</span>)</span><br><span class="line">entries = Entry.objects.filter(blog__name__in=inner_qs)</span><br></pre></td></tr></table></figure><ul><li>gt：大于</li><li>gte：大于等于</li><li>lt：小于</li><li>lte：小于等于</li><li>startswith：大小写敏感的以**开头</li><li>istartswith：忽略大小写的以**开头</li><li>endswith：大小写敏感的以**结尾</li><li>iendswith：忽略大小写的以**结尾</li><li>range：包含的范围，类似 SQL 中的 BETWEEN</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line">start_date = datetime.date(<span class="number">2005</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">end_date = datetime.date(<span class="number">2005</span>, <span class="number">3</span>, <span class="number">31</span>)</span><br><span class="line">Entry.objects.filter(pub_date__range=(start_date, end_date))</span><br></pre></td></tr></table></figure><ul><li>year：对日期／时间字段精确匹配年份，年份用四位数字表示</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(pub_date__year=<span class="number">2005</span>)</span><br></pre></td></tr></table></figure><p>等价于SQL：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... WHERE EXTRACT(&apos;year&apos; FROM pub_date) = &apos;2005&apos;;</span><br></pre></td></tr></table></figure><ul><li>month：对日期／时间字段精确匹配月份</li><li>day：对日期／时间字段精确匹配日期</li><li>week_day：对日期／时间字段精确匹配周数</li><li>hour：对日期／时间字段精确匹配小时</li><li>minute：对日期／时间字段精确匹配分钟</li><li>second：对日期／时间字段精确匹配秒</li><li>isnull：根据字段是否为空筛选数据</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(pub_date__isnull=<span class="keyword">True</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT ... WHERE pub_date IS NULL;</span><br></pre></td></tr></table></figure><ul><li>search：利用全文索引做全文搜索，与 contains 类似，但使用全文索引会更快</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.filter(headline__search=<span class="string">"+Django -jazz Python"</span>)</span><br></pre></td></tr></table></figure><ul><li>regex：大小写敏感的正则表达式匹配</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry.objects.get(title__regex=<span class="string">r'^(An?|The) +'</span>)</span><br></pre></td></tr></table></figure><ul><li>iregex：忽略大小写的正则表达式匹配</li></ul><h1 id="聚合函式"><a href="#聚合函式" class="headerlink" title="聚合函式"></a>聚合函式</h1><ul><li>avg：<field>__avg ，返回所给字段的平均值</field></li><li>count：<field>__count ，返回所给关联字段的 model 数量</field></li><li>max：<field>__max ，返回所给字段数据的最大值</field></li><li>min：<field>__min , 返回所给字段数据的最小值</field></li><li>strdev：<field>__stddev ，返回所给字段的标准差，sample=True 返回一个样本偏差值</field></li><li>sum：<field>__sum ，计算所给字段的和</field></li><li>variance：<field>__variance ，计算所给字段的标准方差，sample=True 返回样本方差</field></li></ul>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>常见的魔术方法</title>
      <link href="//%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
      <url>//%E5%B8%B8%E8%A7%81%E7%9A%84%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="类的基础方法"><a href="#类的基础方法" class="headerlink" title="类的基础方法"></a>类的基础方法</h1><ul><li><code>__init__</code> : 初始化一个实例，调用在实例创建之后</li><li><code>__new__</code> : 创建一个实例，操作实例的实际创建进程</li><li><code>__repr__</code> : 字符串的官方表现形式</li><li><code>__str__</code> : 字符串的非正式值，<code>print()</code> 调用</li><li><code>__bytes__</code> : 字节数组的非正式值</li><li><code>__format__</code> : 格式化字符串的值</li></ul><h1 id="行为方式与迭代器类似的类"><a href="#行为方式与迭代器类似的类" class="headerlink" title="行为方式与迭代器类似的类"></a>行为方式与迭代器类似的类</h1><ul><li><code>__iter__</code> : 遍历某个序列，创建迭代器，初始化迭代器</li><li><code>__next__</code> : 从迭代器中获取下一个值</li><li><code>__reversed__</code> : 按逆序创建一个迭代器</li></ul><h1 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h1><ul><li><code>__getattribute__</code> : 获取一个计算属性（无条件的）</li><li><code>__getattr__</code> : 获取一个计算属性（后备）</li><li><code>__setattr__</code> : 设置某属性</li><li><code>__delattr__</code> : 删除某属性</li><li><code>__dir__</code> : 列出所有属性和方法，同 <code>dir()</code></li><li><code>__len__</code> : 计算序列的长度</li><li><code>__contains__</code> : 了解序列是否包含特定的值，<code>x in seq</code> </li><li><code>__getitem__</code> : 通过键获取值，<code>x[key]</code></li><li><code>__setitem__</code> : 通过键设置值，<code>x[key]=value</code></li><li><code>__delitem__</code> : 删除一个键值对</li><li><code>__missing__</code> : 为缺失键提供默认值，<code>x[nonexistent]</code></li></ul><h1 id="可比较的类"><a href="#可比较的类" class="headerlink" title="可比较的类"></a>可比较的类</h1><ul><li><code>__eq__</code> : 相等， <code>x==y</code></li><li><code>__ne__</code> : 不相等，<code>x!=y</code></li><li><code>__lt__</code> : 小于，<code>x&lt;y</code></li><li><code>__le__</code> : 小于或等于，<code>x&lt;=y</code></li><li><code>__gt__</code> : 大于，<code>x&gt;y</code></li><li><code>__ge__</code> : 大于或等于，<code>x&gt;=y</code></li><li><code>__bool__</code> : 布尔上下文环境中的真值，<code>if x:</code></li></ul><h1 id="可序列化的类"><a href="#可序列化的类" class="headerlink" title="可序列化的类"></a>可序列化的类</h1><ul><li><code>__copy__</code> : 自定义对象的复制</li><li><code>__deepcopy__</code> : 自定义对象的深度复制</li><li><code>__getstate__</code> : 在 picking 之前获取对象的状态</li><li><code>__reduce__</code> : 序列化某对象</li><li><code>__reduce_ex__</code> : 序列化某对象（新的 picking 协议）</li><li><code>__getnewargs__</code> : 控制 unpicking 过程中对象的创建方式</li><li><code>__setstate__</code> : 控制 unpicking 之后恢复对象的状态</li></ul><h1 id="可在-with-语块中使用的类"><a href="#可在-with-语块中使用的类" class="headerlink" title="可在 with 语块中使用的类"></a>可在 with 语块中使用的类</h1><ul><li><code>__enter__</code> : 在进入 with 语块时执行的特别操作</li><li><code>__exit__</code> : 在退出 with 语块 时执行的特别操作。with 语块执行结束后总是自动保存文件实际就是在 <code>__exit__()</code> 方法中调用了 <code>self.close()</code> 方法。</li></ul><h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><ul><li><code>__new__</code> : 类构造器。<a href="https://zhuanlan.zhihu.com/p/21379984" target="_blank" rel="noopener"><code>__new__</code>和<code>__init__</code>的区别</a></li><li><code>__del__</code> : 删除对象，回收。</li><li><code>__hash__</code> : 自定义散列值</li><li><code>__get__</code> : 获取某个属性的值 <code>type(x).__dict__[&#39;color&#39;].__get__(x, type(x))</code></li><li><code>__set__</code> : 设置某个属性的值 <code>type(x).__dict__[&#39;color&#39;].__set__(x, &#39;PapayaWhip&#39;)</code></li><li><code>__del__</code> : 删除某个属性的值 <code>type(x).__dict__[&#39;color&#39;].__del__(x)</code></li><li><code>__isinstansecheck__</code> : 控制某个对象是否是该对象的实例</li><li><code>__subclasscheck__</code> : 控制某个类是否是该类的子类</li><li><code>__subclasshock__</code> : 控制某个类是否是该抽象基类的子类</li><li><code>__add__</code> : 等价于 <code>x+y</code></li><li><code>__base__</code> : 关于类继承和函数查找路径</li><li><code>__bases__</code> : 关于类继承和函数查找路径 </li><li><code>__mro__</code> : 关于类继承和函数查找路径</li><li><code>__subclasses__</code> : 返回子类列表</li><li><code>__call__</code> : 定义对象在调用时的操作</li><li><code>__cmp__</code> : 在比较的时候调用</li><li><code>__sizeof__</code> : 对象在内存中的字节数</li><li><code>__basicsize__</code> : 类在内存中的字节数</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://pycoders-weekly-chinese.readthedocs.io/en/latest/issue6/a-guide-to-pythons-magic-methods.html" target="_blank" rel="noopener">python魔术方法指南</a></li></ul>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>pipenv 使用总结</title>
      <link href="//pipenv%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>//pipenv%20%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一般Python项目管理虚拟环境和包依赖都使用的是pip+virtualenv的方案，但日常使用中还是有些麻烦。跟Node.js的npm类似，pipenv是Python项目的依赖管理器。可以很方便的管理项目虚拟环境、包依赖以及开发环境。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install pipenv</span><br></pre></td></tr></table></figure><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><ul><li>创建项目目录</li><li>进入项目目录</li><li><p>使用以下命令创建虚拟环境</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install</span><br></pre></td></tr></table></figure></li><li><p>使用以下命令进入虚拟环境</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv shell</span><br></pre></td></tr></table></figure></li><li><p>安装项目所使用的包（以flask为例）</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pipenv install flask</span><br></pre></td></tr></table></figure></li></ul><p>安装过程如下：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">➜  test <span class="built_in">mkdir</span> pipenvtest</span><br><span class="line">➜  test <span class="built_in">cd</span> pipenvtest</span><br><span class="line">➜  pipenvtest pipenv install</span><br><span class="line">Creating a virtualenv <span class="keyword">for</span> this project…</span><br><span class="line">⠋Using base prefix '/usr/local/Cellar/python3/<span class="number">3</span>.<span class="number">6</span>.<span class="number">4</span>_2/Frameworks/Python.framework/Versions/<span class="number">3</span>.<span class="number">6</span>'</span><br><span class="line">New python executable <span class="keyword">in</span> /Users/zhd/.local/share/virtualenvs/pipenvtest-<span class="number">1914</span>ZQu8/bin/python3.<span class="number">6</span></span><br><span class="line">Also creating executable <span class="keyword">in</span> /Users/zhd/.local/share/virtualenvs/pipenvtest-<span class="number">1914</span>ZQu8/bin/python</span><br><span class="line">Installing setuptools, pip, wheel...done.</span><br><span class="line"></span><br><span class="line">Virtualenv location: /Users/zhd/.local/share/virtualenvs/pipenvtest-<span class="number">1914</span>ZQu8</span><br><span class="line">Creating a Pipfile <span class="keyword">for</span> this project…</span><br><span class="line">Pipfile.lock <span class="keyword">not</span> found, creating…</span><br><span class="line">Locking [dev-packages] dependencies…</span><br><span class="line">Locking [packages] dependencies…</span><br><span class="line">Updated Pipfile.lock (c23e27)!</span><br><span class="line">Installing dependencies from Pipfile.lock (c23e27)…</span><br><span class="line">  🐍   ▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉▉ <span class="number">0</span>/<span class="number">0</span> — <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span></span><br><span class="line">To activate this project's virtualenv, run the following:</span><br><span class="line"> $ pipenv shell</span><br></pre></td></tr></table></figure></p><p>pipenv会自动生成两个文件：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">➜  pipenvtest ls</span><br><span class="line">Pipfile      Pipfile.lock</span><br></pre></td></tr></table></figure></p><p>文件内容如下：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="keyword">source</span>]]</span><br><span class="line"></span><br><span class="line">url = <span class="string">"https://pypi.python.org/simple"</span></span><br><span class="line">verify_ssl = true</span><br><span class="line">name = <span class="string">"pypi"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[packages]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[dev-packages]</span><br><span class="line"></span><br><span class="line">~</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure></p><p>里面可以修改Pypi源，packages里面记录的是该项目环境所安装的包（会自动记录版本号），每次使用install命令安装包后pipenv都会自动更新这部分的内容。dev-packages里面记录的是开发环境所使用的包，如果安装包是指定为开发环境模式，则该包会记录在这一部分。</p><h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># pipenv <span class="built_in">help</span></span><br><span class="line">pipenv install --python <span class="number">2</span>.<span class="number">7</span></span><br><span class="line">pipenv install --python <span class="number">3</span>.<span class="number">6</span></span><br><span class="line"><span class="function">    Options:</span></span><br><span class="line"><span class="function">  --<span class="title">update</span>         <span class="title">Update</span> <span class="title">Pipenv</span> &amp; <span class="title">pip</span> <span class="title">to</span> <span class="title">latest</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">where</span>          <span class="title">Output</span> <span class="title">project</span> <span class="title">home</span> <span class="title">information</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">venv</span>           <span class="title">Output</span> <span class="title">virtualenv</span> <span class="title">information</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">py</span>             <span class="title">Output</span> <span class="title">Python</span> <span class="title">interpreter</span> <span class="title">information</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">envs</span>           <span class="title">Output</span> <span class="title">Environment</span> <span class="title">Variable</span> <span class="title">options</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">rm</span>             <span class="title">Remove</span> <span class="title">the</span> <span class="title">virtualenv</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">bare</span>           <span class="title">Minimal</span> <span class="title">output</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">completion</span>     <span class="title">Output</span> <span class="title">completion</span> (<span class="title">to</span> <span class="title">be</span> <span class="title">evald</span>).</span></span><br><span class="line"><span class="function">  --<span class="title">man</span>            <span class="title">Display</span> <span class="title">manpage</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">three</span> / --<span class="title">two</span>  <span class="title">Use</span> <span class="title">Python</span> 3/2 <span class="title">when</span> <span class="title">creating</span> <span class="title">virtualenv</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">python</span> <span class="title">TEXT</span>    <span class="title">Specify</span> <span class="title">which</span> <span class="title">version</span> <span class="title">of</span> <span class="title">Python</span> <span class="title">virtualenv</span> <span class="title">should</span> <span class="title">use</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">site</span>-<span class="title">packages</span>  <span class="title">Enable</span> <span class="title">site</span>-<span class="title">packages</span> <span class="title">for</span> <span class="title">the</span> <span class="title">virtualenv</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">jumbotron</span>      <span class="title">An</span> <span class="title">easter</span> <span class="title">egg</span>, <span class="title">effectively</span>.</span></span><br><span class="line"><span class="function">  --<span class="title">version</span>        <span class="title">Show</span> <span class="title">the</span> <span class="title">version</span> <span class="title">and</span> <span class="title">exit</span>.</span></span><br><span class="line"><span class="function">  -<span class="title">h</span>, --<span class="title">help</span>       <span class="title">Show</span> <span class="title">this</span> <span class="title">message</span> <span class="title">and</span> <span class="title">exit</span>.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>property 装饰器的使用</title>
      <link href="//property%20%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>//property%20%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<p>property装饰器广泛应用在类的定义中，可以让调用者写出简短的代码，同时保证对参数进行必要的检查。并且可以把一个方法变成属性调用。<br>举个🌰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">birth</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">age</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2018</span> - self._birth</span><br></pre></td></tr></table></figure><p>直接根据属性调用 <code>getter</code> 和 <code>setter</code> ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=Student()</span><br><span class="line">a.birth=<span class="number">2012</span>  <span class="comment"># setter</span></span><br><span class="line">a.birth   <span class="comment"># getter     return: 2012</span></span><br><span class="line">a.age  <span class="comment"># getter     return: 6</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>类方法和静态方法</title>
      <link href="//%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
      <url>//%E7%B1%BB%E6%96%B9%E6%B3%95%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<h1 id="经典的例子"><a href="#经典的例子" class="headerlink" title="经典的例子"></a>经典的例子</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, day=<span class="number">0</span>, month=<span class="number">0</span>, year=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.day = day</span><br><span class="line">        self.month = month</span><br><span class="line">        self.year = year</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">from_string</span><span class="params">(cls, date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        date1 = cls(day, month, year)</span><br><span class="line">        <span class="keyword">return</span> date1</span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_date_valid</span><span class="params">(date_as_string)</span>:</span></span><br><span class="line">        day, month, year = map(int, date_as_string.split(<span class="string">'-'</span>))</span><br><span class="line">        <span class="keyword">return</span> day &lt;= <span class="number">31</span> <span class="keyword">and</span> month &lt;= <span class="number">12</span> <span class="keyword">and</span> year &lt;= <span class="number">3999</span></span><br><span class="line"></span><br><span class="line">date2 = Date.from_string(<span class="string">'11-09-2012'</span>)</span><br><span class="line">is_date = Date.is_date_valid(<span class="string">'11-09-2012'</span>)</span><br></pre></td></tr></table></figure><h1 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod"></a>classmethod</h1><ol><li>由于python类中只能有一个初始化方法，不能按照不同的情况初始化类。所以类方法常用来模拟多个构造函数（重构构造函数）</li><li>子类的实例继承了父类的类方法，调用该方法，调用的是子类的方法和类属性</li></ol><h1 id="staticmethod"><a href="#staticmethod" class="headerlink" title="staticmethod"></a>staticmethod</h1><ul><li>一般的使用场景是和类相关的操作，但又不依赖和改变类、实例的状态。<ul><li>例如要实现某一个类的全局计数功能，就可以使用classmethod封装新建实例的操作。</li><li>子类的实例继承父类的静态方法，调用该方法，调用的是父类的方法和父类的类属性。</li></ul></li><li>staticmethod 主要用途是限定 namespace，也就是说这个函数虽然是个普通的 function ，但是它只有这个 class 会用到，不适合作为 module level 的 function。这时候就把它作为 staticmethod 。如果不考虑 namespace 的问题的话直接在 module 里面 def function 就行了。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>爬虫基础知识</title>
      <link href="//%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>//%E7%88%AC%E8%99%AB%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      <content type="html"><![CDATA[<h1 id="正则表达式（python中使用re包）"><a href="#正则表达式（python中使用re包）" class="headerlink" title="正则表达式（python中使用re包）"></a>正则表达式（python中使用re包）</h1><ol><li>^ ： 以某个字符开头，例如^b，为字母b开头</li><li>. ：代表任意字符</li><li>* ： 前面的字符出现任意多次，例如“^b.*”代表以b开头，后面任意位任意字符的字符串</li><li>$ ： 代表以某个字符结尾。例如3$意味以3结尾</li><li>？： 是一种非贪婪匹配的模式，默认为贪婪匹配（倒序查找），例如“.*?(b.*?b).*”，匹配“booooobbby”，输出为“booooob” ，如果第二个b不加？，则会贪婪匹配从右边开始，即匹配到最后一个b</li><li>（）： 提取括号中的子字符串</li><li>‘+’ ： 至少出现一次</li><li>{} ： 限定出现的次数</li><li>| ： 或</li><li>[] ： 字符串匹配中括号中的任意一个字符都可以，[0-9]意味区间，[^1]意味不等于1</li><li>\s \S ： s代表空格，S代表不为空格</li><li>\w \W ： 代表字母下划线，W代表非字母下划线</li><li>[\u4E00-\u9FA5] ： 代表汉字</li><li>\b ： 代表数字</li></ol><h1 id="深度优先和广度优先遍历算法"><a href="#深度优先和广度优先遍历算法" class="headerlink" title="深度优先和广度优先遍历算法"></a>深度优先和广度优先遍历算法</h1><h1 id="url常见去重策略"><a href="#url常见去重策略" class="headerlink" title="url常见去重策略"></a>url常见去重策略</h1><ol><li>将访问过的URL保存到数据库中</li><li>将访问过的URL储存在set中，只需要0（1）的代价就可以查询url</li><li>URL经过md5等hash运算后保存在set中</li><li>用bitmap方法，把访问过的url通过hash函数映射到某一位</li><li>bloomfilter方法对hash算法进行改进，多重hash函数降低冲突</li></ol><h1 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h1><ol><li>计算机只能处理数字，文本必须转换为数字才能处理。计算机中以8个bit作为一个字节，所以一个字节能表示的最大的数字就是255</li><li>计算机是美国人发明的，所以一个字节就能表示所有的字符，所以ASC||（一个字节）就成了美国人的标准编码</li><li>ASCII码处理中文明显是不够的，所以中国制定了GB2312编码，用两个字节表示一个汉字。GB2312还把ASCII包含进去了，同理日本、韩国等国家都各有一套自己的编码，如此一来，出现多种语言混合的文本就会出现乱码。</li><li>Unicode是将所有语言统一到一套编码里。乱码问题解决了，但是如果文本内容全部都是英文的话，传输和储存需要的空间就扩大了一倍。</li><li>utf-8，可以变长的编码。英文压缩至一个字节，汉字三个字节，特别生僻的4个字节。但是utf-8在编程处理的时候会变的复杂（内存运算复杂）</li><li>所以一般的做法是储存文件使用utf-8编码，内存运算时使用Unicode编码。Python2Windows默认为GB2312编码，Linux默认为UTF-8编码，在做decode运算的时候要先转换为Unicode，Python3默认为Unicode编码</li></ol>]]></content>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅谈区块链与数字货币</title>
      <link href="//%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/"/>
      <url>//%E6%B5%85%E8%B0%88%E5%8C%BA%E5%9D%97%E9%93%BE%E4%B8%8E%E6%95%B0%E5%AD%97%E8%B4%A7%E5%B8%81/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今年谈起金融科技，最热莫过于区块链。工作之余，也要多关注行业技术进展。现阶段基于区块链的项目泡沫很大，有的项目甚至没有落地，仅凭一张白皮书也能通过ICO募资千万（一种类似IPO的集资手段，通过向公众发放代币，引入比特币、以太坊、莱特币等价值币的投资，转而在二级市场售出。代币持有者并不持有同比例股权和享受分红权利，从而绕过政策监管）。资本和媒体的接连吹捧，韭菜挤破头入市……热度完全不亚于前两年的P2P和私募股权。以至于有的传销组织也拿区块链做出类似比特币的各种山寨币吸金（如张健五行币、亚欧币、GCB、EGD、万福币等约上百币种）……作为FinTech从业人员，我们需要从技术角度剥茧抽丝，辩其真身。</p><h1 id="什么是区块链"><a href="#什么是区块链" class="headerlink" title="什么是区块链"></a>什么是区块链</h1><p>从技术方面来看，其本质是一种分布式系统，没有主从结构，所有的节点都保存全量数据。例如比特币，用户可以随意创建一个26位到34位的账户地址，每个账户地址对应一把私钥，私钥就是你拥有其对应账户资产的凭证。私钥通过SHA-256散列运算生成公钥，公钥再经过RIPEMD-160散列运算生成账户地址。也就是说以目前计算机的计算能力没有办法通过你的账户地址破解你的私钥，你的资产是安全的，这也是目前比特币作为近几年最有价值的投资品的原因之一。账户之间点对点进行交易，交易生成的订单在区块链上进行确认，区块链上的节点（也就是全网所有运行区块链程序的计算机，可以理解为整个交易系统的记账员，每个节点都是记账员）不停的扔硬币去争夺每十分钟一次的记账权，谁抢到了这段时间的记账权，就把这段时间的所有交易打包为一个块，广播给全网其他节点进行同步，抢到记账权的记账员会收到一定量奖励，包括用户交易的手续费。通过上面的分析，我们可以看出区块链主要有以下三个特点：</p><ul><li>安全。目前的计算能力无法从公钥反推私钥，除非自己泄密，否则账户里的资产就无法盗取。交易记录全节点全量保存，相当于做了很多容灾备份，也规避了账本被随意更改的风险。</li><li>去中心化。每个节点都高度自治，就像《失控》中描写蚁群和蜂群一样：”这是民主制度的精髓，是彻底的分布式管理“。任何人都是一个节点，任何人也都可以成为一个中心。整个系统不需要第三方去管理或控制，一定程度上节约了人力和维护成本，也避免了传统金融系统中可能出现的腐败。</li><li>信息透明。所有在公有链上的交易都是可查的，并且可以追踪到账户。</li></ul><h1 id="区块链的应用"><a href="#区块链的应用" class="headerlink" title="区块链的应用"></a>区块链的应用</h1><p>目前区块链的主要应用在于金融服务、征信和权属管理、资源共享、投资管理、物联网和供应链等。例如比特币是基于区块链技术的数字货币方面的应用，目前已经自治稳定运行了很多年，在跨国结算、日常结算、价值储存、资产避险等场景中已崭露头角。这只是区块链作为分布式储存的一种应用，区块链技术还能带来通用的计算能力，使它成为一种分布式的计算引擎，大家可以通过付费来使用算力，是不是有点普适计算的味道？实际已经有人这么做了——那就是 Ethereum （以太坊） 。</p><p>以太坊基于区块链又做了一层平台层，并且实现了基于区块链的轻量虚拟机EVM，让别人可以基于平台开发应用。以太坊的主要开发语言是Golang、C++和Python，为了打造这个平台，官方还提供了一条公有链和对应的智能合约开发语言Solidity。它不像比特币网络里只有一种符号比特币，以太坊除了官方的代币ETH，你可以给自己开发的应用创建相应的Token（代币），可以和ETH流通。而以太坊官网开源了创建代币等多种智能合约的源码，这也就解释了篇首提到的为什么山寨币泛滥，因为Copy代码之后修改修改，再写一份说得过去的白皮书，就可以在众筹网站开启众筹，因为使用的是比特币、以太坊、莱特币等虚拟资产，绕过了政策监管。投资者以相当低的成本价格购入代币，等项目上线虚拟币交易所如聚币、比特儿等二级市场，再慢慢售出谋取暴利。有的圈钱项目还在ICO当天官方内部通过技术手段获取大部分代币额度，在ICO刚刚结束就上线交易所并以成本价格的3~5倍卖出，制造舆论忽悠“韭菜们”接盘。当然，目前的虚拟币交易所也没有相关正式的政策法规约束。</p><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>大浪淘沙，虽然目前国内区块链领域被劣质的圈钱项目和ICO“玩儿坏了“，但不可否认区块链的技术优势。随着监管的到来、法规的进一步完善，也会涌现出一批像Fabric、The DAO、OMG、NEO、Kyber等优质的区块链应用。结合公司目前的情况来说，谈区块链还为时尚早，应用场景有限。以江源农商行为例，虽然可以使用Fabric搭设私链开发分布式账本，简化业务手续、提升经营效率并缩减成本，生成不可更改的交易数据，以此衍生搭建用户的征信评级系统。或者通过搭设以太坊私链编写智能合约实现理财产品的购买交易、自动分红、收取利息、审核小额贷款等功能。但以目前的情况去开发并不理智。一是因为农商行规模比较小，改造成本非常大且效益有限；二是因为上述的问题使用现有技术也可以解决；三是政策监管不明朗，区块链的去中心化、自治的特性生来与国家、监管等中心化概念相左，目前国内相关案例不多，没有必要自己踩雷。四是相关技术还没有稳定成熟，源码一直在更新，区块链开发人员稀缺且缺乏项目经验。</p>]]></content>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据库结构简述</title>
      <link href="//%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/"/>
      <url>//%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E7%AE%80%E8%BF%B0/</url>
      <content type="html"><![CDATA[<p>本文主要对基本的数据库结构（Oracle）做一个简介，希望对各位全面的了解数据库有所帮助。</p><h1 id="数据库对象"><a href="#数据库对象" class="headerlink" title="数据库对象"></a>数据库对象</h1><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表是关系型数据存储对象的基本结构</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>基于一个表或多个表或视图的逻辑表，本身不包含数据，通过它可以对表里面的数据进行查询和修改</p><h3 id="视图的优点"><a href="#视图的优点" class="headerlink" title="视图的优点"></a>视图的优点</h3><ul><li>减少对数据库的访问，因为视图可以对字段有选择性的选取</li><li>用户通过简单的查询可以从复杂查询中得到结果</li><li>维护数据的独立性，试图可从多个表检索数据</li><li>对于相同的数据可产生不同的视图</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是可以提高查询性能的数据结构</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li><li>可以大大加快数据的检索速度，这也是创建索引的最主要原因</li><li>可以加速表和表之间的链接</li><li>可使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li></ul><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，会降低数据的维护速度</li></ul><h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><h4 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h4><ul><li>适合大量的增删改（OLTP应用），保证较少的磁盘IO</li><li>每个结点都是数据块</li><li>叶子块数据是排序的，从左到右递增</li><li>不能包含OR操作符的查询</li><li>适合高基数的列（唯一值多）</li><li>典型的树状结构</li><li>大多都是物理上一层、两层或三层不定，逻辑上三层</li></ul><h4 id="哈希索引（HASH）"><a href="#哈希索引（HASH）" class="headerlink" title="哈希索引（HASH）"></a>哈希索引（HASH）</h4><ul><li>适合非范围数据查找</li><li>可能是数据库中读取数据的最快方法</li><li>ALTER CLUSTER命令不能改变HASH键的数目</li></ul><h4 id="位图索引（bitmap）"><a href="#位图索引（bitmap）" class="headerlink" title="位图索引（bitmap）"></a>位图索引（bitmap）</h4><ul><li>适合决策支持系统和数据仓库</li><li>做 UPDATE 代价非常高</li><li>很适合 OR 操作符的查询</li><li>基数比较少的时候才能建位图索引</li></ul><h5 id="使用限制"><a href="#使用限制" class="headerlink" title="使用限制"></a>使用限制</h5><ul><li>基于规则的优化器不会考虑位图索引</li><li>当执行ALTER TABLE语句并修改包含有位图索引的列时，会使位图索引失效</li><li>位图索引不包含任何列数据，并且不能用于任何类型的完整性检查</li><li>位图索引不能被声明为唯一索引</li><li>位图索引的最大长度为30</li><li>不要在繁重的OLTP环境中使用位图索引</li></ul><h4 id="索引（组织）表"><a href="#索引（组织）表" class="headerlink" title="索引（组织）表"></a>索引（组织）表</h4><ul><li>索引组织表会把表的存储结构改成B树结构，以表的主键进行排序。</li><li>ROWID不会被关联到表的行上</li><li>对基于主键值的精确匹配或范围匹配以及UPDATE和DELETE语句，由于行在物理上有序，索引组织表有 很好的表现</li><li>键列的值在表和索引中都没有重复，存储所需要的空间少</li><li>若不会频繁的根据主键列查询数据，则需要在索引组织表中的其他列上创建二级索引</li></ul><h4 id="反转键索引"><a href="#反转键索引" class="headerlink" title="反转键索引"></a>反转键索引</h4><ul><li>为了解决多个用户对集中在少数快上的索引进行修改，容易引起数据块等待的问题</li><li>使有序数列随机化，生成的B-Tree更平衡，读取层级少，从而降低了热数据块</li><li>适合磁盘容量有限，同时还要执行大量的有序载入</li><li>不能对位图索引</li></ul><h4 id="基于函数的索引"><a href="#基于函数的索引" class="headerlink" title="基于函数的索引"></a>基于函数的索引</h4><ul><li>使执行了函数的查询能使用上索引</li><li>需要付出额外的索引的存储空间</li><li>必须初始化参数 QUERY_REWRITE_ENABLED</li></ul><h4 id="分区索引"><a href="#分区索引" class="headerlink" title="分区索引"></a>分区索引</h4><ul><li>将一个索引分成多个片段，可以访问更小的片段，也可以把这些片段分别存放在不同的磁盘驱动器上，能够提供更多可以提高性能和可维护性的可能</li><li>B-Tree和位图索引都可以被分区，而HASH索引不可以被分区</li></ul><h5 id="分区方法"><a href="#分区方法" class="headerlink" title="分区方法"></a>分区方法</h5><ul><li>表被分区而索引未被分区</li><li>表未被分区而索引被分区</li><li>表和索引都被分区</li></ul><h5 id="类型-1"><a href="#类型-1" class="headerlink" title="类型"></a>类型</h5><ul><li>本地分区索引<ul><li>有前缀索引</li><li>无前缀索引</li></ul></li><li>全局分区索引<ul><li>有前缀索引</li><li>无前缀索引</li></ul></li></ul><h2 id="存储过程和函数"><a href="#存储过程和函数" class="headerlink" title="存储过程和函数"></a>存储过程和函数</h2><p>过程和函数都以编译后的形式存放在数据库中，函数有返回值，过程没有返回值，但两者最根本的区别是他们的调用方式。过程作为一个独立的执行语句调用，函数以合法的表达式的方式调用。</p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>包是将过程、函数和数据结构捆绑在一起的容器。</p><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><ul><li>包头</li><li>包体</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是一种自动执行相应数据库变化的程序。可以设置为在触发器事件之前或之后执行。<br>能够触发触发器事件包括下面几种：</p><ul><li>DML事件：数据库操纵语言</li><li>DDL事件：数据库定义语言</li><li>数据库事件</li></ul><h2 id="数据字典"><a href="#数据字典" class="headerlink" title="数据字典"></a>数据字典</h2><p>数据字典包含数据库的元数据。</p><h2 id="完整性约束（规则）"><a href="#完整性约束（规则）" class="headerlink" title="完整性约束（规则）"></a>完整性约束（规则）</h2><p>用于增强数据的完整性</p><ul><li>CHECK：用于限制列中的值的范围</li><li>NOT NULL：强制列不接受NULL值</li><li>UNIQUE：唯一标识数据库表中的每条记录，每张表可以有多个</li><li>PRIMARY KEY：主键约束，唯一标识，主键列不能包含NULL值，每张表只能有一个主键</li><li>FOREIGN KEY：外键约束，指向另一张表中的主键列，预防破坏表之间连接的动作，防止非法数据插入外键列，外键必须是它指向的那个表中的值之一</li></ul><hr><h1 id="用户与权限"><a href="#用户与权限" class="headerlink" title="用户与权限"></a>用户与权限</h1><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><ul><li>对数据库的访问，需要以适当用户身份通过验证，并具有相关权限来完成一系列动作</li><li>SCHEMA：是某个用户所拥有所有对象的集合</li></ul><h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><h3 id="系统权限"><a href="#系统权限" class="headerlink" title="系统权限"></a>系统权限</h3><p>允许用户执行特定的数据库动作，如创建表、创建索引、连接实例等<br>常用的系统权限：</p><ul><li>CREATE SESSION 创建会话</li><li>CREATE SEQUENCE 创建序列</li><li>CREATE SYNONYM 创建同名对象</li><li>CREATE [ANY] TABLE 创建表</li><li>DROP TABLE 删除表</li><li>CREATE PROCEDURE 创建存储过程</li><li>CREATE USER 创建用户</li><li>DROP USER 删除用户</li><li>CREATE [ANY] VIEW 创建视图</li></ul><h3 id="对象权限"><a href="#对象权限" class="headerlink" title="对象权限"></a>对象权限</h3><p>允许用户操纵一些特定的对象，如读取视图、更新某些列、执行存储过程等<br>常见的对象权限：</p><ul><li>ALTER 修改</li><li>DELETE 删除</li><li>EXECUTE 执行</li><li>INDEX 索引</li><li>INSERT 插入</li><li>SELECT 选择</li><li>UPDATE 更新</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>使用CREATE USER 语句创建用户，ALTER USER语句修改用户，DROP USER username会删除用户及其所拥有的所有对象的数据</li><li>系统权限允许用户在数据库中执行特定的操作，如执行DDL语句。</li></ul><p>WITH ADMIN OPTION 使得该用户具有将自身获得的权限授予其他用户的功能<br>但回收对象权限时，不会从其他账户级联取消曾被授予的相同权限</p><ul><li>对象权限允许用户对数据库对象执行特定的操作，如执行DML语句。</li></ul><p>WITH GRANT OPTION 使得该用户具有将自身获得的对象权限授予其他用户的功能<br>但回收对象权限时，会从其他账户级联取消曾被授予的相同权限</p><ul><li>系统权限与对象权限授予时的语法差异为对象权限使用了ON object_name 子句</li><li>PUBLIC 为所有用户授权</li><li>ALL：对象权限中的所有对象权限</li></ul><h2 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h2><p>角色就是相关权限的命令的集合。使用角色的主要目的就是为了简化权限的管理</p><h3 id="预定义角色"><a href="#预定义角色" class="headerlink" title="预定义角色"></a>预定义角色</h3><h4 id="CONNECT-角色"><a href="#CONNECT-角色" class="headerlink" title="CONNECT 角色"></a>CONNECT 角色</h4><p>具有一般应用开发人员需要的大部分权限<br>包括：</p><ul><li>Alter session</li><li>Create cluster</li><li>Create database link</li><li>Create session</li><li>Create table</li><li>Create view</li><li>Create sequence</li><li>……</li></ul><h4 id="RESOURCE-角色"><a href="#RESOURCE-角色" class="headerlink" title="RESOURCE 角色"></a>RESOURCE 角色</h4><p>具有应用开发人员所需要的其他权限，如<br>包括：</p><ul><li>Create procedure</li><li>Create trigger</li><li>……</li></ul><h4 id="DBA-角色"><a href="#DBA-角色" class="headerlink" title="DBA 角色"></a>DBA 角色</h4><p>DBA角色具有所有的系统权限，及with admin option选项，默认的dba用户为sys和system，他们可以将任何系统权限授予其他用户。但是DBA角色不具备sysdba和sysoper的特权（启动和关闭数据库）</p><h4 id="自定义角色"><a href="#自定义角色" class="headerlink" title="自定义角色"></a>自定义角色</h4><ul><li>建立角色<ul><li>建立不验证的角色</li><li>Create role 角色名 not identified</li></ul></li><li>建立数据库验证的角色<ul><li>Create role 角色名 identified by 密码</li></ul></li><li>角色授权<ul><li>Grant insert,update,delete on object_name to角色名</li></ul></li><li>分配角色给某个用户<ul><li>Grant 角色名 to 用户名 with admin option</li></ul></li></ul><h4 id="删除角色"><a href="#删除角色" class="headerlink" title="删除角色"></a>删除角色</h4><p>Drop role 角色名</p><h1 id="事务和锁"><a href="#事务和锁" class="headerlink" title="事务和锁"></a>事务和锁</h1><p>##事务</p><p>事务是数据库管理系统执行过程中的一个逻辑单位，由一个有限的对数据库的读/写操作序列构成</p><h3 id="存在的目的"><a href="#存在的目的" class="headerlink" title="存在的目的"></a>存在的目的</h3><ul><li>为数据库操作提供了一个从失败中回复到正常状态的方法，同时提供了数据库即使在异常状态下仍然能保持一致性的方法</li><li>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰</li></ul><h3 id="ACID特性"><a href="#ACID特性" class="headerlink" title="ACID特性"></a>ACID特性</h3><ul><li>原子性（Atomicity）<br>  事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行</li><li>一致性（Consistency）<br>  状态前后一致，满足完整性约束</li><li>隔离性（Isolation）<br>  多个事务并发执行时，一个事务的执行不应影响其他事务的执行</li><li>持久性（Durability）<br>  已被提交的事务对数据库的修改应该永久保存在数据库中</li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ul><li>Read uncommitted 未提交读，容易造成脏读。事务B读取了事务A尚未提交的数据。</li><li>Read committed 已提交读，容易造成不可重复读。事务A事先读取了数据正准备做一些操作，事务B紧接着更新了数据，并提交了事务，而事务A再次使用该数据时，数据已经发生了改变。不可重复读的重点是修改，同样条件读取过的数据，再次读取出来发现值不一样了。</li><li>Read  Repeatable 可重复读，可能造成幻读。事务A读取数据并打算做一些操作，此时事务B更新了数据并提交，事务A再读取时数据发生了变化。幻读的重点在于新增或删除，同样的条件，第一次和第二次读出来的记录数不一样。从总的结果看，幻读和不可重复读都表现为两次读取的结果不一致。但如果从控制的角度来看，对于后者只需要锁住满足条件的记录，对于前者，要锁住满足条件及其相近的记录。</li><li>Serializable 序列化。最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用。在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。</li></ul><h3 id="自制事务"><a href="#自制事务" class="headerlink" title="自制事务"></a>自制事务</h3><p>事务的“要么全部完成，要么什么都没完成”的本性会使将错误信息记入数据库表中变得很困难，因为当事务失败重新运行时，用来编写日志条目的INSERT语句没有完成。针对这种困境，可以用自治事务来解决。自治事务从当前事务开始，在其自身的语境中执行。它们能独立地被提交或重新运行，而不影响正在运行的事务。正因为这样，它们成了编写错误日志表格的理想形式。在事务中检测到错误时，可以在错误日志表格中插入一行并提交它，然后在不丢失这次插入的情况下回滚主事务。</p><h1 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h1><p>数据库是一个多用户使用的共享资源。当多个用户并发地存取数据时，在数据库中就会产生多个事务同时存取同一数据的情况。若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。加锁是实现数据库并发控制的一个非常重要的技术。当事务在对某个数据对象进行操作前，先向系统发出请求，对其加锁。加锁后事务就对该数据有了一定的控制，在该事务释放锁之前，其他的事务不能对此数据对象进行更新操作。</p><p>##基本的锁类型</p><ul><li>共享锁<ul><li>可以被其他事务读取，但不能修改</li></ul></li><li>排它锁<ul><li>其他事务不能对它读取和修改</li></ul></li><li>粒度<ul><li>行级锁</li><li>表级锁</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> database </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
