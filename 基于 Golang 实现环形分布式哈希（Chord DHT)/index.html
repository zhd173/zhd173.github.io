<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
    <meta name="description" content="声明本文译自: Chord: Building a DHT (Distributed Hash Table) in Golang 什么是分布式哈希表？分布式哈希表是分布式系统的一种类别，它将键值对数据以哈希表的形式储存在分布式系统中，系统中的任何节点都可以有效的检索键值。  分布式散列表（英语：distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个关键值（k">
<meta property="og:type" content="article">
<meta property="og:title" content="基于 Golang 实现环形分布式哈希表">
<meta property="og:url" content="https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/index.html">
<meta property="og:site_name" content="海东的博客">
<meta property="og:description" content="声明本文译自: Chord: Building a DHT (Distributed Hash Table) in Golang 什么是分布式哈希表？分布式哈希表是分布式系统的一种类别，它将键值对数据以哈希表的形式储存在分布式系统中，系统中的任何节点都可以有效的检索键值。  分布式散列表（英语：distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个关键值（k">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4050229477,530984799&fm=26&gp=0.jpg">
<meta property="og:image" content="https://miro.medium.com/max/500/0*WqXs3F73o7NGlXuJ.png">
<meta property="og:image" content="https://miro.medium.com/max/1700/0*ma9nP6ZPZ2OwEvvN.png">
<meta property="og:image" content="https://miro.medium.com/max/1600/1*4ScEqacqOK_hOWwQeFNgLw.gif">
<meta property="article:published_time" content="2019-11-03T06:52:41.000Z">
<meta property="article:modified_time" content="2020-09-30T02:34:09.483Z">
<meta property="article:author" content="zhd173">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4050229477,530984799&fm=26&gp=0.jpg">
    
    
        
          
              <link rel="shortcut icon" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=16">
          
        
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=192" sizes="192x192">
          
        
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/b2af0ca47828868e8906600eb33f51f3?s=180">
          
        
    
    <!-- title -->
    <title>基于 Golang 实现环形分布式哈希表</title>
    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
      
<link rel="stylesheet" href="/css/rtl.css">

    
    <!-- rss -->
    
    
<meta name="generator" content="Hexo 5.1.1"></head>

<body class="max-width mx-auto px3 ltr">
    
      <div id="header-post">
  <a id="menu-icon" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="menu-icon-tablet" href="#"><i class="fas fa-bars fa-lg"></i></a>
  <a id="top-icon-tablet" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');" style="display:none;"><i class="fas fa-chevron-up fa-lg"></i></a>
  <span id="menu">
    <span id="nav">
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </span>
    <br/>
    <span id="actions">
      <ul>
        
        <li><a class="icon" href="/Pilot%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"><i class="fas fa-chevron-left" aria-hidden="true" onmouseover="$('#i-prev').toggle();" onmouseout="$('#i-prev').toggle();"></i></a></li>
        
        
        <li><a class="icon" href="/Golang%20%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AF%8A%E6%96%AD/"><i class="fas fa-chevron-right" aria-hidden="true" onmouseover="$('#i-next').toggle();" onmouseout="$('#i-next').toggle();"></i></a></li>
        
        <li><a class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up" aria-hidden="true" onmouseover="$('#i-top').toggle();" onmouseout="$('#i-top').toggle();"></i></a></li>
        <li><a class="icon" href="#"><i class="fas fa-share-alt" aria-hidden="true" onmouseover="$('#i-share').toggle();" onmouseout="$('#i-share').toggle();" onclick="$('#share').toggle();return false;"></i></a></li>
      </ul>
      <span id="i-prev" class="info" style="display:none;">上一篇</span>
      <span id="i-next" class="info" style="display:none;">下一篇</span>
      <span id="i-top" class="info" style="display:none;">返回顶部</span>
      <span id="i-share" class="info" style="display:none;">分享文章</span>
    </span>
    <br/>
    <div id="share" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/"><i class="fab fa-facebook " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&text=基于 Golang 实现环形分布式哈希表"><i class="fab fa-twitter " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-linkedin " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&is_video=false&description=基于 Golang 实现环形分布式哈希表"><i class="fab fa-pinterest " aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=基于 Golang 实现环形分布式哈希表&body=Check out this article: https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/"><i class="fas fa-envelope " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-get-pocket " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-reddit " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-stumbleupon " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-digg " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&name=基于 Golang 实现环形分布式哈希表&description="><i class="fab fa-tumblr " aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&t=基于 Golang 实现环形分布式哈希表"><i class="fab fa-hacker-news " aria-hidden="true"></i></a></li>
</ul>

    </div>
    <div id="toc">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是分布式哈希表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.</span> <span class="toc-text">分布式哈希表的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">什么是一致性哈希？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.</span> <span class="toc-text">一致性哈希的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Chord-%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">什么是 Chord 算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">7.</span> <span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.1.</span> <span class="toc-text">1.基本查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B0%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5"><span class="toc-number">7.2.</span> <span class="toc-text">2.新节点加入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A8%B3%E5%AE%9A"><span class="toc-number">7.3.</span> <span class="toc-text">3.稳定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>
  </span>
</div>

    
    <div class="content index py4">
        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  <header>
    
    <h1 class="posttitle" itemprop="name headline">
        基于 Golang 实现环形分布式哈希表
    </h1>



    <div class="meta">
      <span class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">海东的博客</span>
      </span>
      
    <div class="postdate">
      
        <time datetime="2019-11-03T06:52:41.000Z" itemprop="datePublished">2019-11-03</time>
        
      
    </div>


      

      
    <div class="article-tag">
        <i class="fas fa-tag"></i>
        <a class="tag-link-link" href="/tags/go/" rel="tag">go</a>
    </div>


    </div>
  </header>
  

  <div class="content" itemprop="articleBody">
    <h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p><em>本文译自: <a target="_blank" rel="noopener" href="https://medium.com/techlog/chord-building-a-dht-distributed-hash-table-in-golang-67c3ce17417b">Chord: Building a DHT (Distributed Hash Table) in Golang</a></em></p>
<h2 id="什么是分布式哈希表？"><a href="#什么是分布式哈希表？" class="headerlink" title="什么是分布式哈希表？"></a>什么是分布式哈希表？</h2><p>分布式哈希表是分布式系统的一种类别，它将键值对数据以哈希表的形式储存在分布式系统中，系统中的任何节点都可以有效的检索键值。</p>
<blockquote>
<p>分布式散列表（英语：distributed hash table，缩写DHT）是分布式计算系统中的一类，用来将一个关键值（key）的集合分散到所有在分布式系统中的节点，并且可以有效地将消息转送到唯一一个拥有查询者提供的关键值的节点（Peers）。这里的节点类似散列表中的存储位置。分布式散列表通常是为了拥有极大节点数量的系统，而且在系统的节点常常会加入或离开（例如网络断线）而设计的。在一个结构性的延展网络（overlay network）中，参加的节点需要与系统中一小部分的节点沟通，这也需要使用分布式散列表。分布式散列表可以用以创建更复杂的服务，例如分布式文件系统、点对点技术文件分享系统、合作的网页缓存、多播、任播、域名系统以及即时通信等。(维基百科)</p>
</blockquote>
<p>每个节点都有维护各自键值映射的责任。</p>
<p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=4050229477,530984799&fm=26&gp=0.jpg" alt="分布式哈希表"></p>
<h2 id="分布式哈希表的性质"><a href="#分布式哈希表的性质" class="headerlink" title="分布式哈希表的性质"></a>分布式哈希表的性质</h2><p>分布式散列表一般强调以下特性：</p>
<ul>
<li>离散性：也就是去中心化，构成系统的节点没有任何中央式的协调机制。</li>
<li>伸缩性：即使有成千上万个节点，系统仍然十分有效率。</li>
<li>容错性：即时接地点不断的加入、离开或者停止工作，系统仍然十分可靠。</li>
</ul>
<h2 id="什么是一致性哈希？"><a href="#什么是一致性哈希？" class="headerlink" title="什么是一致性哈希？"></a>什么是一致性哈希？</h2><p>普通的哈希算法，在分布式系统中如果某个节点断开或新增节点时，计算的哈希值很可能在节点中找不到，无法保证一致性，需要重新计算所有的键值映射，成本非常高。而一致性哈希就是想让每次节点变动导致重新计算映射的成本尽可能的低一些。在使用一致性哈希算法后，哈希表大小的改变平均只需要对 <code>K/n</code> 个关键字重新映射，其中 <code>K</code> 是关键字的数量，<code>n</code> 是槽位数量。</p>
<h2 id="一致性哈希的性质"><a href="#一致性哈希的性质" class="headerlink" title="一致性哈希的性质"></a>一致性哈希的性质</h2><ul>
<li>平衡性：指哈希的结果均匀分散到各个缓冲区中去，避免出现热点。</li>
<li>单调性：指添加节点后，原有的哈希结果要么不迁移，要么迁移到新的节点，不会迁移到旧的节点。</li>
<li>分散性：尽量降低同一内容被映射到不同缓冲区中的概率。</li>
<li>负载：尽量降低某个节点的负荷，避免同一缓冲区被不同的值映射。</li>
<li>平滑性：指系统中节点数目的平滑改变应该和键值对象的平滑改变是一致的。</li>
</ul>
<h2 id="什么是-Chord-算法？"><a href="#什么是-Chord-算法？" class="headerlink" title="什么是 Chord 算法？"></a>什么是 Chord 算法？</h2><p>在计算机领域，Chord 是一个点对点分布式哈希表的协议和算法。是 P2P 中的四大算法之一（其他三个分别是 CAN、Pastry、Tapestry），Chord 只负责如何把给定的键分配给节点，以及节点如何定位负责该键的节点进而找到给定键的值。</p>
<p><img src="https://miro.medium.com/max/500/0*WqXs3F73o7NGlXuJ.png" alt="Chord"></p>
<p>Chord 算法是基于一致性哈希的，更多信息可以参考 Ion Stoica，Robert Morris，David Karger，Frans Kaashoek 和 Hari Balakrishnan 的论文：<a target="_blank" rel="noopener" href="https://pdos.csail.mit.edu/papers/ton:chord/paper-ton.pdf">original paper</a>。</p>
<h2 id="实现细节"><a href="#实现细节" class="headerlink" title="实现细节"></a>实现细节</h2><h3 id="1-基本查询"><a href="#1-基本查询" class="headerlink" title="1.基本查询"></a>1.基本查询</h3><p>Chord 协议的核心用途就是从客户端（节点）查询一个 key。显然，任何查找只要沿着 Chord 环一圈肯定能找到，但是这会导致时间复杂度为 <code>O(N)</code>, <code>N</code> 是环中的节点数。这对于一个上百万节点，且节点经常加入、退出的 P2P 网络来说是无法忍受的。为了避免上面的线性搜索，Chord 实现了一种更快的非线性搜索方法。这要求每个节点记录一张包含 <code>m</code> 条数据的 <code>finger</code> 表，因为 Chord 算法采用 <code>SHA-1</code> 作为哈希函数，<code>SHA-1</code> 会生成一个 2<sup>160</sup> 的空间，所以 <code>finger</code> 表的长度为 160。</p>
<p><img src="https://miro.medium.com/max/1700/0*ma9nP6ZPZ2OwEvvN.png" alt="Chord-finger"></p>
<p>该表的第 i 项值将存放节点 <code>n</code>的第 ((n+2<sup>i-1</sup>) mod 2<sup>m</sup>) 个后继节点（successor）。<code>finger</code>表的第一个条目实际上是节点的直接后继字段（因此不需要额外的后继字段）。每当一个节点想要查找一个键 <code>k</code> 时，它都会将查询传递给它 <code>finger</code> 表中最近的前继或后继节点（环中比<code>ID</code>比<code>k</code>小的最大值），直到一个节点发现 <code>k</code> 储存在它的直接后继节点中。这样的算法时间复杂度为 <code>O(logN)</code>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// fingerEntry represents a single finger table entry</span></span><br><span class="line"><span class="keyword">type</span> fingerEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">   Id   []<span class="keyword">byte</span>         <span class="comment">// ID hash of (n + 2^i) mod (2^m)</span></span><br><span class="line">   Node *internal.Node </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFingerTable</span><span class="params">(node *internal.Node, m <span class="keyword">int</span>)</span> <span class="title">fingerTable</span></span> &#123;</span><br><span class="line">   ft := <span class="built_in">make</span>([]*fingerEntry, m)</span><br><span class="line">   <span class="keyword">for</span> i := <span class="keyword">range</span> ft &#123;</span><br><span class="line">    ft[i] = newFingerEntry(fingerID(node.Id, i, m), node)</span><br><span class="line">   &#125;</span><br><span class="line">  <span class="keyword">return</span> ft</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// newFingerEntry returns an allocated new finger entry with the attributes set</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newFingerEntry</span><span class="params">(id []<span class="keyword">byte</span>, node *internal.Node)</span> *<span class="title">fingerEntry</span></span> &#123;</span><br><span class="line">   <span class="keyword">return</span> &amp;fingerEntry&#123;</span><br><span class="line">    Id:   id,</span><br><span class="line">    Node: node,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Computes the offset by (n + 2^i) mod (2^m)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fingerID</span><span class="params">(n []<span class="keyword">byte</span>, i <span class="keyword">int</span>, m <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123;</span><br><span class="line">   <span class="comment">// Convert the ID to a bigint</span></span><br><span class="line">   idInt := (&amp;big.Int&#123;&#125;).SetBytes(n)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get the offset</span></span><br><span class="line">   two := big.NewInt(<span class="number">2</span>)</span><br><span class="line">   offset := big.Int&#123;&#125;</span><br><span class="line">   offset.Exp(two, big.NewInt(<span class="keyword">int64</span>(i)), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Sum</span></span><br><span class="line">   sum := big.Int&#123;&#125;</span><br><span class="line">   sum.Add(idInt, &amp;offset)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Get the ceiling</span></span><br><span class="line">   ceil := big.Int&#123;&#125;</span><br><span class="line">   ceil.Exp(two, big.NewInt(<span class="keyword">int64</span>(m)), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Apply the mod</span></span><br><span class="line">   idInt.Mod(&amp;sum, &amp;ceil)</span><br><span class="line">   <span class="comment">// Add together</span></span><br><span class="line">   <span class="keyword">return</span> idInt.Bytes()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-新节点加入"><a href="#2-新节点加入" class="headerlink" title="2.新节点加入"></a>2.新节点加入</h3><p>每当有新节点加入时，都应该维护三个不变量（前两个确保正确性，后一个保证快速查询）：</p>
<ol>
<li>每个节点的后继节点正确的指向其直接后继节点</li>
<li>每个 <code>key</code> 都存储在后续 <code>k</code> 中</li>
<li>每个节点的 <code>finger</code> 表应该是正确的</li>
</ol>
<p>为了满足这些不变量，为每个节点维护一个前置字段。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">  *internal.Node</span><br><span class="line">  predecessor *internal.Node</span><br><span class="line">  successor *internal.Node</span><br><span class="line">  fingerTable fingerTable</span><br><span class="line">  storage Storage</span><br><span class="line">  transport Transport</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于新加入的节点<code>n</code>，应该执行以下任务：</p>
<ol>
<li>初始化节点<code>n</code>的前置表和<code>finger</code>表</li>
<li>通知其他节点更新其前置和<code>finger</code>表</li>
<li>新节点从其后继节点接管其负责的 <code>key</code></li>
</ol>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(n *Node)</span> <span class="title">join</span><span class="params">(joinNode *internal.Node)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// First check if node already present in the circle</span></span><br><span class="line">    <span class="comment">// Join this node to the same chord ring as parent</span></span><br><span class="line">    <span class="keyword">var</span> foo *internal.Node</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Ask if our id already exists on the ring.</span></span><br><span class="line">    <span class="keyword">if</span> joinNode != <span class="literal">nil</span> &#123;</span><br><span class="line">        remoteNode, err := n.findSuccessorRPC(joinNode, n.Id)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> isEqual(remoteNode.Id, n.Id) &#123;</span><br><span class="line">            <span class="keyword">return</span> ERR_NODE_EXISTS</span><br><span class="line">        &#125;</span><br><span class="line">        foo = joinNode</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        foo = n.Node</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    succ, err := n.findSuccessorRPC(foo, n.Id)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    n.succMtx.Lock()</span><br><span class="line">    n.successor = succ</span><br><span class="line">    n.succMtx.Unlock()</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>N 的前继节点可以很容易的从 <code>successor(n)</code> 的前继（在前一个循环中）获得。对于 <code>finger</code> 表，有各种初始化方法。最简单的方法就是对所有 <code>m</code> 条目执行所有的后继节点查询。结果是 <code>O(M/logN)</code>。一个更好的方法是检查 <code>finger</code> 表中的 i<sup>th</sup> 条目对于 (i+1)<sup>th</sup> 条目是否仍然准确。这样时间复杂度为 O(log<sup>2</sup>N)。</p>
<h3 id="3-稳定"><a href="#3-稳定" class="headerlink" title="3.稳定"></a>3.稳定</h3><p>为了确保正确的查找，所有后继指针都必须是最新的。因此需要运行一个稳定的后台进程更新 <code>finger</code> 表和后继指针。</p>
<p>其工作方式如下：</p>
<ul>
<li>stabilize(): 为其前继 <code>p</code> 询问他的后继节点，并决定 <code>p</code> 是否应该作为 <code>n</code>的后继节点。</li>
<li>notify(): 通知 <code>n</code> 的后继节点它的存在，因此它可以将其前身更改为 <code>n</code>。</li>
<li>fix_fingers(): 更新 <code>finger</code> 表</li>
<li>check_predecessor(): 定期检查前继节点是否处于活动状态。</li>
</ul>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    NewNode creates a new Chord node. Returns error if node already</span></span><br><span class="line"><span class="comment">    exists in the chord ring</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewNode</span><span class="params">(cnf *Config, joinNode *internal.Node)</span> <span class="params">(*Node, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> err := cnf.Validate(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    node := &amp;Node&#123;</span><br><span class="line">    	Node:       <span class="built_in">new</span>(internal.Node),</span><br><span class="line">    	shutdownCh: <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;),</span><br><span class="line">    	cnf:        cnf,</span><br><span class="line">    	storage:    NewMapStore(cnf.Hash),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> nID <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">if</span> cnf.Id != <span class="string">&quot;&quot;</span> &#123;</span><br><span class="line">    	nID = cnf.Id</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    	nID = cnf.Addr</span><br><span class="line">    &#125;</span><br><span class="line">    id, err := node.hashKey(nID)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    aInt := (&amp;big.Int&#123;&#125;).SetBytes(id)</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">&quot;new node id %d, \n&quot;</span>, aInt)</span><br><span class="line"></span><br><span class="line">    node.Node.Id = id</span><br><span class="line">    node.Node.Addr = cnf.Addr</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Populate finger table</span></span><br><span class="line">    node.fingerTable = newFingerTable(node.Node, cnf.HashSize)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start RPC server</span></span><br><span class="line">    transport, err := NewGrpcTransport(cnf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    node.transport = transport</span><br><span class="line"></span><br><span class="line">    internal.RegisterChordServer(transport.server, node)</span><br><span class="line"></span><br><span class="line">    node.transport.Start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> err := node.join(joinNode); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Peridoically stabilize the node.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	ticker := time.NewTicker(<span class="number">1</span> * time.Second)</span><br><span class="line">    	<span class="keyword">for</span> &#123;</span><br><span class="line">    		<span class="keyword">select</span> &#123;</span><br><span class="line">    		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">    			node.stabilize()</span><br><span class="line">    		<span class="keyword">case</span> &lt;-node.shutdownCh:</span><br><span class="line">    			ticker.Stop()</span><br><span class="line">    			<span class="keyword">return</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Peridoically fix finger tables.</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	next := <span class="number">0</span></span><br><span class="line">    	ticker := time.NewTicker(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">    	<span class="keyword">for</span> &#123;</span><br><span class="line">    		<span class="keyword">select</span> &#123;</span><br><span class="line">    		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">    			next = node.fixFinger(next)</span><br><span class="line">    		<span class="keyword">case</span> &lt;-node.shutdownCh:</span><br><span class="line">    			ticker.Stop()</span><br><span class="line">    			<span class="keyword">return</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Peridoically checkes whether predecessor has failed.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	ticker := time.NewTicker(<span class="number">10</span> * time.Second)</span><br><span class="line">    	<span class="keyword">for</span> &#123;</span><br><span class="line">    		<span class="keyword">select</span> &#123;</span><br><span class="line">    		<span class="keyword">case</span> &lt;-ticker.C:</span><br><span class="line">    			node.checkPredecessor()</span><br><span class="line">    		<span class="keyword">case</span> &lt;-node.shutdownCh:</span><br><span class="line">    			ticker.Stop()</span><br><span class="line">    			<span class="keyword">return</span></span><br><span class="line">    		&#125;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> node, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大部分的细节可以在论文中找到。这里有一个简单的 <code>gif</code> 来演示 DHT 的工作：</p>
<p><img src="https://miro.medium.com/max/1600/1*4ScEqacqOK_hOWwQeFNgLw.gif" alt="DHT-Work"></p>
<p>当一个节点停机时，该节点的 <code>key</code> 将被转换至后继节点上。</p>
<p>以下为代码：</p>
<pre><code>https://github.com/arriqaaq/chord</code></pre>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/v_JULY_v/article/details/6256463">从头到尾理解 Hash 表算法</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5ae1476ef265da0b8d419ef2">五分钟看懂一致性哈希算法</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/chen77716/article/details/6059575">Chord 算法原理</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/43048791">一致性哈希和分布式哈希</a></li>
</ol>

  </div>
</article>

    <div class="blog-post-comments">
        <div id="disqus_thread">
            <noscript>加载评论需要在浏览器启用 JavaScript 脚本支持。</noscript>
        </div>
    </div>



        
          <div id="footer-post-container">
  <div id="footer-post">

    <div id="nav-footer" style="display: none">
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </div>

    <div id="toc-footer" style="display: none">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">什么是分布式哈希表？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">3.</span> <span class="toc-text">分布式哈希表的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">什么是一致性哈希？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">5.</span> <span class="toc-text">一致性哈希的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Chord-%E7%AE%97%E6%B3%95%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">什么是 Chord 算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">7.</span> <span class="toc-text">实现细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.1.</span> <span class="toc-text">1.基本查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%96%B0%E8%8A%82%E7%82%B9%E5%8A%A0%E5%85%A5"><span class="toc-number">7.2.</span> <span class="toc-text">2.新节点加入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A8%B3%E5%AE%9A"><span class="toc-number">7.3.</span> <span class="toc-text">3.稳定</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">8.</span> <span class="toc-text">参考</span></a></li></ol>
    </div>

    <div id="share-footer" style="display: none">
      <ul>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&text=基于 Golang 实现环形分布式哈希表"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&is_video=false&description=基于 Golang 实现环形分布式哈希表"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" href="mailto:?subject=基于 Golang 实现环形分布式哈希表&body=Check out this article: https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/"><i class="fas fa-envelope fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&title=基于 Golang 实现环形分布式哈希表"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&name=基于 Golang 实现环形分布式哈希表&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li>
  <li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://haidong.dev/%E5%9F%BA%E4%BA%8E%20Golang%20%E5%AE%9E%E7%8E%B0%E7%8E%AF%E5%BD%A2%E5%88%86%E5%B8%83%E5%BC%8F%E5%93%88%E5%B8%8C%EF%BC%88Chord%20DHT)/&t=基于 Golang 实现环形分布式哈希表"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li>
</ul>

    </div>

    <div id="actions-footer">
        <a id="menu" class="icon" href="#" onclick="$('#nav-footer').toggle();return false;"><i class="fas fa-bars fa-lg" aria-hidden="true"></i> 菜单</a>
        <a id="toc" class="icon" href="#" onclick="$('#toc-footer').toggle();return false;"><i class="fas fa-list fa-lg" aria-hidden="true"></i> 目录</a>
        <a id="share" class="icon" href="#" onclick="$('#share-footer').toggle();return false;"><i class="fas fa-share-alt fa-lg" aria-hidden="true"></i> 分享</a>
        <a id="top" style="display:none" class="icon" href="#" onclick="$('html, body').animate({ scrollTop: 0 }, 'fast');"><i class="fas fa-chevron-up fa-lg" aria-hidden="true"></i> 返回顶部</a>
    </div>

  </div>
</div>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2016-2020
    zhd173
  </div>
  <div class="footer-right">
    <nav>
      <ul>
         
          <li><a href="/archives/">Blog</a></li>
         
          <li><a href="/gtags/">Tags</a></li>
         
          <li><a href="/TODO/">TODO</a></li>
         
          <li><a target="_blank" rel="noopener" href="https://github.com/zhd173">GitHub</a></li>
        
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->

<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">


<link rel="stylesheet" href="/lib/justified-gallery/css/justifiedGallery.min.css">


    <!-- jquery -->

<script src="/lib/jquery/jquery.min.js"></script>


<script src="/lib/justified-gallery/js/jquery.justifiedGallery.min.js"></script>

<!-- clipboard -->

  
<script src="/lib/clipboard/clipboard.min.js"></script>

  <script type="text/javascript">
  $(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"复制到粘贴板!\">";
    btn += '<i class="far fa-clone"></i>';
    btn += '</span>'; 
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "复制成功!");
      e.clearSelection();
    })
  })
  </script>


<script src="/js/main.js"></script>

<!-- search -->

<!-- Google Analytics -->

    <script type="text/javascript">
        (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject']=r;i[r]=i[r]||function() {
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
        ga('create', 'UA-125225753-1', 'auto');
        ga('send', 'pageview');
    </script>

<!-- Baidu Analytics -->

<!-- Disqus Comments -->

    <script type="text/javascript">
        var disqus_shortname = 'haidongdev';

        (function(){
            var dsq = document.createElement('script');
            dsq.type = 'text/javascript';
            dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        }());
    </script>


</body>
</html>
